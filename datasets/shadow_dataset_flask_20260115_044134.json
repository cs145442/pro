[
  {
    "id": "pr-5818",
    "description": "pass context through dispatch methods\n\nThe current `AppContext` object is passed through the various request dispatch methods, rather than each method accessing the proxies. closes #5815 \r\n\r\n@pgjones first proposed this in #5229 as a way to speed up dispatch especially for Quart and async views. This PR applies to more methods, and also implements compatibility during a deprecation period.\r\n\r\nDispatch methods now take `ctx: AppContext` as the first parameter. The following `Flask` methods were changed:\r\n\r\n- `update_template_context`\r\n- `handle_http_exception`\r\n- `handle_user_exception`\r\n- `handle_exception`\r\n- `log_exception`\r\n- `dispatch_request`\r\n- `full_dispatch_request`\r\n- `finalize_request`\r\n- `make_default_options_response`\r\n- `preprocess_request`\r\n- `process_response`\r\n- `do_teardown_request`\r\n- `do_teardown_appcontext`\r\n\r\n`url_for` and `make_response` were not changed, as it's much more likely that these are called from user code that only has access to the proxy.\r\n\r\nAn `__init_subclass__` class method is added to detect old signatures on subclasses of `Flask`. The second parameter is inspected (first is self). If it is not annotated, it must be named `ctx`. If it is annotated, it must either be the string or class `AppContext`. If an old signature is detected, the method is wrapped to remove the argument when other `Flask` methods call it during dispatch. The base method is also wrapped to inject the argument so that `super().base_method` from the overridden method will continue to work.\r\n\r\nI did not apply the compat wrapper to every base `Flask` method, only the ones that a subclass overrides. Therefore, if user code is directly calling these internal dispatch methods, they will get a `TypeError`. This is only likely (and unlikely at that) to happen during testing. I did this over concern that the wrapper would be unnecessary and a performance hit for most applications. If we get bug reports we can consider adding the wrapper.",
    "has_bug": false,
    "base_commit": "adf363679da2d9a5ddc564bb2da563c7ca083916",
    "pr_url": "https://github.com/pallets/flask/pull/5818",
    "merged_at": "2025-11-17T16:49:53Z",
    "expected_files": [
      "CHANGES.rst",
      "src/flask/app.py",
      "src/flask/ctx.py",
      "src/flask/templating.py",
      "tests/test_reqctx.py",
      "tests/test_subclassing.py"
    ],
    "oracle_tests": {
      "tests/test_reqctx.py": "import warnings\n\nimport pytest\n\nimport flask\nfrom flask.globals import app_ctx\nfrom flask.sessions import SecureCookieSessionInterface\nfrom flask.sessions import SessionInterface\n\ntry:\n    from greenlet import greenlet\nexcept ImportError:\n    greenlet = None\n\n\ndef test_teardown_on_pop(app):\n    buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    ctx = app.test_request_context()\n    ctx.push()\n    assert buffer == []\n    ctx.pop()\n    assert buffer == [None]\n\n\ndef test_teardown_with_previous_exception(app):\n    buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    try:\n        raise Exception(\"dummy\")\n    except Exception:\n        pass\n\n    with app.test_request_context():\n        assert buffer == []\n    assert buffer == [None]\n\n\ndef test_teardown_with_handled_exception(app):\n    buffer = []\n\n    @app.teardown_request\n    def end_of_request(exception):\n        buffer.append(exception)\n\n    with app.test_request_context():\n        assert buffer == []\n        try:\n            raise Exception(\"dummy\")\n        except Exception:\n            pass\n    assert buffer == [None]\n\n\ndef test_proper_test_request_context(app):\n    app.config.update(SERVER_NAME=\"localhost.localdomain:5000\")\n\n    @app.route(\"/\")\n    def index():\n        return None\n\n    @app.route(\"/\", subdomain=\"foo\")\n    def sub():\n        return None\n\n    with app.test_request_context(\"/\"):\n        assert (\n            flask.url_for(\"index\", _external=True)\n            == \"http://localhost.localdomain:5000/\"\n        )\n\n    with app.test_request_context(\"/\"):\n        assert (\n            flask.url_for(\"sub\", _external=True)\n            == \"http://foo.localhost.localdomain:5000/\"\n        )\n\n    # suppress Werkzeug 0.15 warning about name mismatch\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\", \"Current server name\", UserWarning, \"flask.app\"\n        )\n        with app.test_request_context(\n            \"/\", environ_overrides={\"HTTP_HOST\": \"localhost\"}\n        ):\n            pass\n\n    app.config.update(SERVER_NAME=\"localhost\")\n    with app.test_request_context(\"/\", environ_overrides={\"SERVER_NAME\": \"localhost\"}):\n        pass\n\n    app.config.update(SERVER_NAME=\"localhost:80\")\n    with app.test_request_context(\n        \"/\", environ_overrides={\"SERVER_NAME\": \"localhost:80\"}\n    ):\n        pass\n\n\ndef test_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    @app.route(\"/meh\")\n    def meh():\n        return flask.request.url\n\n    with app.test_request_context(\"/?name=World\"):\n        assert index() == \"Hello World!\"\n    with app.test_request_context(\"/meh\"):\n        assert meh() == \"http://localhost/meh\"\n    assert not flask.request\n\n\ndef test_context_test(app):\n    assert not flask.request\n    assert not flask.has_request_context()\n    ctx = app.test_request_context()\n    ctx.push()\n    try:\n        assert flask.request\n        assert flask.has_request_context()\n    finally:\n        ctx.pop()\n\n\ndef test_manual_context_binding(app):\n    @app.route(\"/\")\n    def index():\n        return f\"Hello {flask.request.args['name']}!\"\n\n    ctx = app.test_request_context(\"/?name=World\")\n    ctx.push()\n    assert index() == \"Hello World!\"\n    ctx.pop()\n    with pytest.raises(RuntimeError):\n        index()\n\n\n@pytest.mark.skipif(greenlet is None, reason=\"greenlet not installed\")\nclass TestGreenletContextCopying:\n    def test_greenlet_context_copying(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n            ctx = app_ctx.copy()\n\n            def g():\n                assert not flask.request\n                assert not flask.current_app\n                with ctx:\n                    assert flask.request\n                    assert flask.current_app == app\n                    assert flask.request.path == \"/\"\n                    assert flask.request.args[\"foo\"] == \"bar\"\n                    assert flask.session.get(\"fizz\") == \"buzz\"\n                assert not flask.request\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n    def test_greenlet_context_copying_api(self, app, client):\n        greenlets = []\n\n        @app.route(\"/\")\n        def index():\n            flask.session[\"fizz\"] = \"buzz\"\n\n            @flask.copy_current_request_context\n            def g():\n                assert flask.request\n                assert flask.current_app == app\n                assert flask.request.path == \"/\"\n                assert flask.request.args[\"foo\"] == \"bar\"\n                assert flask.session.get(\"fizz\") == \"buzz\"\n                return 42\n\n            greenlets.append(greenlet(g))\n            return \"Hello World!\"\n\n        rv = client.get(\"/?foo=bar\")\n        assert rv.data == b\"Hello World!\"\n\n        result = greenlets[0].run()\n        assert result == 42\n\n\ndef test_session_error_pops_context():\n    class SessionError(Exception):\n        pass\n\n    class FailingSessionInterface(SessionInterface):\n        def open_session(self, app, request):\n            raise SessionError()\n\n    class CustomFlask(flask.Flask):\n        session_interface = FailingSessionInterface()\n\n    app = CustomFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        # shouldn't get here\n        AssertionError()\n\n    response = app.test_client().get(\"/\")\n    assert response.status_code == 500\n    assert not flask.request\n    assert not flask.current_app\n\n\ndef test_session_dynamic_cookie_name():\n    # This session interface will use a cookie with a different name if the\n    # requested url ends with the string \"dynamic_cookie\"\n    class PathAwareSessionInterface(SecureCookieSessionInterface):\n        def get_cookie_name(self, app):\n            if flask.request.url.endswith(\"dynamic_cookie\"):\n                return \"dynamic_cookie_name\"\n            else:\n                return super().get_cookie_name(app)\n\n    class CustomFlask(flask.Flask):\n        session_interface = PathAwareSessionInterface()\n\n    app = CustomFlask(__name__)\n    app.secret_key = \"secret_key\"\n\n    @app.route(\"/set\", methods=[\"POST\"])\n    def set():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get\")\n    def get():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    @app.route(\"/set_dynamic_cookie\", methods=[\"POST\"])\n    def set_dynamic_cookie():\n        flask.session[\"value\"] = flask.request.form[\"value\"]\n        return \"value set\"\n\n    @app.route(\"/get_dynamic_cookie\")\n    def get_dynamic_cookie():\n        v = flask.session.get(\"value\", \"None\")\n        return v\n\n    test_client = app.test_client()\n\n    # first set the cookie in both /set urls but each with a different value\n    assert test_client.post(\"/set\", data={\"value\": \"42\"}).data == b\"value set\"\n    assert (\n        test_client.post(\"/set_dynamic_cookie\", data={\"value\": \"616\"}).data\n        == b\"value set\"\n    )\n\n    # now check that the relevant values come back - meaning that different\n    # cookies are being used for the urls that end with \"dynamic cookie\"\n    assert test_client.get(\"/get\").data == b\"42\"\n    assert test_client.get(\"/get_dynamic_cookie\").data == b\"616\"\n\n\ndef test_bad_environ_raises_bad_request():\n    app = flask.Flask(__name__)\n\n    from flask.testing import EnvironBuilder\n\n    builder = EnvironBuilder(app)\n    environ = builder.get_environ()\n\n    # use a non-printable character in the Host - this is key to this test\n    environ[\"HTTP_HOST\"] = \"\\x8a\"\n\n    with app.request_context(environ) as ctx:\n        response = app.full_dispatch_request(ctx)\n\n    assert response.status_code == 400\n\n\ndef test_environ_for_valid_idna_completes():\n    app = flask.Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello World!\"\n\n    from flask.testing import EnvironBuilder\n\n    builder = EnvironBuilder(app)\n    environ = builder.get_environ()\n\n    # these characters are all IDNA-compatible\n    environ[\"HTTP_HOST\"] = \"\u0105\u015b\u017a\u00e4\u00fc\u0436\u0160\u00df\u044f.com\"\n\n    with app.request_context(environ) as ctx:\n        response = app.full_dispatch_request(ctx)\n\n    assert response.status_code == 200\n\n\ndef test_normal_environ_completes():\n    app = flask.Flask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return \"Hello World!\"\n\n    response = app.test_client().get(\"/\", headers={\"host\": \"xn--on-0ia.com\"})\n    assert response.status_code == 200\n",
      "tests/test_subclassing.py": "from io import StringIO\n\nimport flask\n\n\ndef test_suppressed_exception_logging():\n    class SuppressedFlask(flask.Flask):\n        def log_exception(self, ctx, exc_info):\n            pass\n\n    out = StringIO()\n    app = SuppressedFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        raise Exception(\"test\")\n\n    rv = app.test_client().get(\"/\", errors_stream=out)\n    assert rv.status_code == 500\n    assert b\"Internal Server Error\" in rv.data\n    assert not out.getvalue()\n"
    }
  },
  {
    "id": "pr-5829",
    "description": "Docs typo/markup fixes\n\nJust two typos I've run into.",
    "has_bug": true,
    "base_commit": "adf363679da2d9a5ddc564bb2da563c7ca083916",
    "pr_url": "https://github.com/pallets/flask/pull/5829",
    "merged_at": "2025-10-14T20:26:26Z",
    "expected_files": [
      "docs/appcontext.rst",
      "docs/design.rst"
    ],
    "oracle_tests": {}
  },
  {
    "id": "pr-5812",
    "description": "merge app and request context\n\nMerges the `RequestContext` class into the `AppContext` class. closes #5639\r\n\r\nA lot of the size of this PR is rewriting or cleaning up docs related to the contexts. See `ctx.py` for the bulk of the work, and even there it's pretty much no new code, mostly deduplication. The \"request context\" still exists, but what data is available on the context object is what distinguishes it from an \"app context\" now.\r\n\r\nHow the user works with the context is pretty much unchanged. For example, `teardown_request` and `teardown_appcontext` still both exist, `app.app_context` and `app.test_request_context`, etc. All the same global proxies, `current_app`, `g`, `request`, and `session` still exist and are still available. in the same situations they were before.\r\n\r\nThe difference is that we no longer have to track whether an app context is already pushed when pushing a request context. This was already sort of an artificial behavior, it was not something that would ever happen under intended/documented request or testing scenarios. Now, every request always sets the app, and the request if request data is given. This greatly simplifies the internal data, as we simply need to record the previous value of the context var to restore on pop.\r\n\r\nSome code in app internals was changed to use the contextvar directly, which code was already doing. This probably gains some tiny bit of performance rather than going through the proxies. When we go ahead with #5229 and beyond, we'll be passing around the context objects directly and won't even need to use the contextvar.\r\n\r\n---\r\n\r\nThere are a few implications for testing that may have used `with app.app_context()` around a test client request. I've already highly discouraged this practice in issues over the years because it was already causing other issues. None of these patterns were in our docs.\r\n\r\nWith the old behavior, an app context was not pushed if one was already pushed when pushing a request context. Therefore,  `teardown_app` functions would only run once the `with` block exited rather than when the request exited. Along with using `with client` around everything, this was already the source of occasional bug reports and questions. The docs also say that no assumptions should be made about how many times a teardown function will be called or what data will be set for them.\r\n\r\nAlso, `g` was part of the app context, not the request context. Data could be set on `g` ahead of the request, because a new app context wouldn't be pushed. This was never documented, I don't know where I saw it.\r\n\r\n```python\r\n# do not do this, for example only\r\nwith app.app_context():\r\n    g.user = test_user\r\n    r = client.get(\"/secret\")\r\n```\r\n\r\nIt's not in Flask's docs or tests. The docs show making a request to login before making the request being tested, relying on the session to persist across requests. If you _really_ wanted to set up `g` beforehand, the signal docs show using the `appcontext_pushed` signal to modify the current context's `g` once it's created.\r\n\r\nA project may run into some failed tests when upgrading, if they were relying on this. However, the failure would indicate patterns that were already unsound and should be fixed, so I don't see this as a blocker.\r\n\r\nInterestingly, `copy_current_request_context` was already not copying `g`. I thought about changing this, but concluded that it was a good thing, because `g` is often used to store connections/caches that are not concurrent safe, such as Flask-SQLAlchemy's `db.session`.",
    "has_bug": false,
    "base_commit": "330123258e8c3dc391cbe55ab1ed94891ca83af3",
    "pr_url": "https://github.com/pallets/flask/pull/5812",
    "merged_at": "2025-09-19T23:45:27Z",
    "expected_files": [
      "CHANGES.rst",
      "docs/api.rst",
      "docs/appcontext.rst",
      "docs/design.rst",
      "docs/extensiondev.rst",
      "docs/index.rst",
      "docs/lifecycle.rst",
      "docs/patterns/sqlalchemy.rst",
      "docs/patterns/sqlite3.rst",
      "docs/patterns/streaming.rst",
      "docs/quickstart.rst",
      "docs/reqcontext.rst",
      "docs/shell.rst",
      "docs/signals.rst",
      "docs/testing.rst",
      "docs/tutorial/blog.rst",
      "docs/tutorial/database.rst",
      "docs/tutorial/templates.rst",
      "docs/tutorial/tests.rst",
      "docs/tutorial/views.rst",
      "src/flask/app.py",
      "src/flask/cli.py",
      "src/flask/ctx.py",
      "src/flask/debughelpers.py",
      "src/flask/globals.py",
      "src/flask/helpers.py",
      "src/flask/json/__init__.py",
      "src/flask/sansio/app.py",
      "src/flask/sansio/scaffold.py",
      "src/flask/templating.py"
    ],
    "oracle_tests": {
      "docs/testing.rst": "Testing Flask Applications\n==========================\n\nFlask provides utilities for testing an application. This documentation\ngoes over techniques for working with different parts of the application\nin tests.\n\nWe will use the `pytest`_ framework to set up and run our tests.\n\n.. code-block:: text\n\n    $ pip install pytest\n\n.. _pytest: https://docs.pytest.org/\n\nThe :doc:`tutorial </tutorial/index>` goes over how to write tests for\n100% coverage of the sample Flaskr blog application. See\n:doc:`the tutorial on tests </tutorial/tests>` for a detailed\nexplanation of specific tests for an application.\n\n\nIdentifying Tests\n-----------------\n\nTests are typically located in the ``tests`` folder. Tests are functions\nthat start with ``test_``, in Python modules that start with ``test_``.\nTests can also be further grouped in classes that start with ``Test``.\n\nIt can be difficult to know what to test. Generally, try to test the\ncode that you write, not the code of libraries that you use, since they\nare already tested. Try to extract complex behaviors as separate\nfunctions to test individually.\n\n\nFixtures\n--------\n\nPytest *fixtures* allow writing pieces of code that are reusable across\ntests. A simple fixture returns a value, but a fixture can also do\nsetup, yield a value, then do teardown. Fixtures for the application,\ntest client, and CLI runner are shown below, they can be placed in\n``tests/conftest.py``.\n\nIf you're using an\n:doc:`application factory </patterns/appfactories>`, define an ``app``\nfixture to create and configure an app instance. You can add code before\nand after the ``yield`` to set up and tear down other resources, such as\ncreating and clearing a database.\n\nIf you're not using a factory, you already have an app object you can\nimport and configure directly. You can still use an ``app`` fixture to\nset up and tear down resources.\n\n.. code-block:: python\n\n    import pytest\n    from my_project import create_app\n\n    @pytest.fixture()\n    def app():\n        app = create_app()\n        app.config.update({\n            \"TESTING\": True,\n        })\n\n        # other setup can go here\n\n        yield app\n\n        # clean up / reset resources here\n\n\n    @pytest.fixture()\n    def client(app):\n        return app.test_client()\n\n\n    @pytest.fixture()\n    def runner(app):\n        return app.test_cli_runner()\n\n\nSending Requests with the Test Client\n-------------------------------------\n\nThe test client makes requests to the application without running a live\nserver. Flask's client extends\n:doc:`Werkzeug's client <werkzeug:test>`, see those docs for additional\ninformation.\n\nThe ``client`` has methods that match the common HTTP request methods,\nsuch as ``client.get()`` and ``client.post()``. They take many arguments\nfor building the request; you can find the full documentation in\n:class:`~werkzeug.test.EnvironBuilder`. Typically you'll use ``path``,\n``query_string``, ``headers``, and ``data`` or ``json``.\n\nTo make a request, call the method the request should use with the path\nto the route to test. A :class:`~werkzeug.test.TestResponse` is returned\nto examine the response data. It has all the usual properties of a\nresponse object. You'll usually look at ``response.data``, which is the\nbytes returned by the view. If you want to use text, Werkzeug 2.1\nprovides ``response.text``, or use ``response.get_data(as_text=True)``.\n\n.. code-block:: python\n\n    def test_request_example(client):\n        response = client.get(\"/posts\")\n        assert b\"<h2>Hello, World!</h2>\" in response.data\n\n\nPass a dict ``query_string={\"key\": \"value\", ...}`` to set arguments in\nthe query string (after the ``?`` in the URL). Pass a dict\n``headers={}`` to set request headers.\n\nTo send a request body in a POST or PUT request, pass a value to\n``data``. If raw bytes are passed, that exact body is used. Usually,\nyou'll pass a dict to set form data.\n\n\nForm Data\n~~~~~~~~~\n\nTo send form data, pass a dict to ``data``. The ``Content-Type`` header\nwill be set to ``multipart/form-data`` or\n``application/x-www-form-urlencoded`` automatically.\n\nIf a value is a file object opened for reading bytes (``\"rb\"`` mode), it\nwill be treated as an uploaded file. To change the detected filename and\ncontent type, pass a ``(file, filename, content_type)`` tuple. File\nobjects will be closed after making the request, so they do not need to\nuse the usual ``with open() as f:`` pattern.\n\nIt can be useful to store files in a ``tests/resources`` folder, then\nuse ``pathlib.Path`` to get files relative to the current test file.\n\n.. code-block:: python\n\n    from pathlib import Path\n\n    # get the resources folder in the tests folder\n    resources = Path(__file__).parent / \"resources\"\n\n    def test_edit_user(client):\n        response = client.post(\"/user/2/edit\", data={\n            \"name\": \"Flask\",\n            \"theme\": \"dark\",\n            \"picture\": (resources / \"picture.png\").open(\"rb\"),\n        })\n        assert response.status_code == 200\n\n\nJSON Data\n~~~~~~~~~\n\nTo send JSON data, pass an object to ``json``. The ``Content-Type``\nheader will be set to ``application/json`` automatically.\n\nSimilarly, if the response contains JSON data, the ``response.json``\nattribute will contain the deserialized object.\n\n.. code-block:: python\n\n    def test_json_data(client):\n        response = client.post(\"/graphql\", json={\n            \"query\": \"\"\"\n                query User($id: String!) {\n                    user(id: $id) {\n                        name\n                        theme\n                        picture_url\n                    }\n                }\n            \"\"\",\n            variables={\"id\": 2},\n        })\n        assert response.json[\"data\"][\"user\"][\"name\"] == \"Flask\"\n\n\nFollowing Redirects\n-------------------\n\nBy default, the client does not make additional requests if the response\nis a redirect. By passing ``follow_redirects=True`` to a request method,\nthe client will continue to make requests until a non-redirect response\nis returned.\n\n:attr:`TestResponse.history <werkzeug.test.TestResponse.history>` is\na tuple of the responses that led up to the final response. Each\nresponse has a :attr:`~werkzeug.test.TestResponse.request` attribute\nwhich records the request that produced that response.\n\n.. code-block:: python\n\n    def test_logout_redirect(client):\n        response = client.get(\"/logout\", follow_redirects=True)\n        # Check that there was one redirect response.\n        assert len(response.history) == 1\n        # Check that the second request was to the index page.\n        assert response.request.path == \"/index\"\n\n\nAccessing and Modifying the Session\n-----------------------------------\n\nTo access Flask's context variables, mainly\n:data:`~flask.session`, use the client in a ``with`` statement.\nThe app and request context will remain active *after* making a request,\nuntil the ``with`` block ends.\n\n.. code-block:: python\n\n    from flask import session\n\n    def test_access_session(client):\n        with client:\n            client.post(\"/auth/login\", data={\"username\": \"flask\"})\n            # session is still accessible\n            assert session[\"user_id\"] == 1\n\n        # session is no longer accessible\n\nIf you want to access or set a value in the session *before* making a\nrequest, use the client's\n:meth:`~flask.testing.FlaskClient.session_transaction` method in a\n``with`` statement. It returns a session object, and will save the\nsession once the block ends.\n\n.. code-block:: python\n\n    from flask import session\n\n    def test_modify_session(client):\n        with client.session_transaction() as session:\n            # set a user id without going through the login route\n            session[\"user_id\"] = 1\n\n        # session is saved now\n\n        response = client.get(\"/users/me\")\n        assert response.json[\"username\"] == \"flask\"\n\n\n.. _testing-cli:\n\nRunning Commands with the CLI Runner\n------------------------------------\n\nFlask provides :meth:`~flask.Flask.test_cli_runner` to create a\n:class:`~flask.testing.FlaskCliRunner`, which runs CLI commands in\nisolation and captures the output in a :class:`~click.testing.Result`\nobject. Flask's runner extends :doc:`Click's runner <click:testing>`,\nsee those docs for additional information.\n\nUse the runner's :meth:`~flask.testing.FlaskCliRunner.invoke` method to\ncall commands in the same way they would be called with the ``flask``\ncommand from the command line.\n\n.. code-block:: python\n\n    import click\n\n    @app.cli.command(\"hello\")\n    @click.option(\"--name\", default=\"World\")\n    def hello_command(name):\n        click.echo(f\"Hello, {name}!\")\n\n    def test_hello_command(runner):\n        result = runner.invoke(args=\"hello\")\n        assert \"World\" in result.output\n\n        result = runner.invoke(args=[\"hello\", \"--name\", \"Flask\"])\n        assert \"Flask\" in result.output\n\n\nTests that depend on an Active Context\n--------------------------------------\n\nYou may have functions that are called from views or commands, that expect an\nactive :doc:`app context </appcontext>` because they access :data:`.request`,\n:data:`.session`, :data:`.g`, or :data:`.current_app`. Rather than testing them by\nmaking a request or invoking the command, you can create and activate a context\ndirectly.\n\nUse ``with app.app_context()`` to push an application context. For\nexample, database extensions usually require an active app context to\nmake queries.\n\n.. code-block:: python\n\n    def test_db_post_model(app):\n        with app.app_context():\n            post = db.session.query(Post).get(1)\n\nUse ``with app.test_request_context()`` to push a request context. It\ntakes the same arguments as the test client's request methods.\n\n.. code-block:: python\n\n    def test_validate_user_edit(app):\n        with app.test_request_context(\n            \"/user/2/edit\", method=\"POST\", data={\"name\": \"\"}\n        ):\n            # call a function that accesses `request`\n            messages = validate_edit_user()\n\n        assert messages[\"name\"][0] == \"Name cannot be empty.\"\n\nCreating a test request context doesn't run any of the Flask dispatching\ncode, so ``before_request`` functions are not called. If you need to\ncall these, usually it's better to make a full request instead. However,\nit's possible to call them manually.\n\n.. code-block:: python\n\n    def test_auth_token(app):\n        with app.test_request_context(\"/user/2/edit\", headers={\"X-Auth-Token\": \"1\"}):\n            app.preprocess_request()\n            assert g.user.name == \"Flask\"\n",
      "docs/tutorial/tests.rst": ".. currentmodule:: flask\n\nTest Coverage\n=============\n\nWriting unit tests for your application lets you check that the code\nyou wrote works the way you expect. Flask provides a test client that\nsimulates requests to the application and returns the response data.\n\nYou should test as much of your code as possible. Code in functions only\nruns when the function is called, and code in branches, such as ``if``\nblocks, only runs when the condition is met. You want to make sure that\neach function is tested with data that covers each branch.\n\nThe closer you get to 100% coverage, the more comfortable you can be\nthat making a change won't unexpectedly change other behavior. However,\n100% coverage doesn't guarantee that your application doesn't have bugs.\nIn particular, it doesn't test how the user interacts with the\napplication in the browser. Despite this, test coverage is an important\ntool to use during development.\n\n.. note::\n    This is being introduced late in the tutorial, but in your future\n    projects you should test as you develop.\n\nYou'll use `pytest`_ and `coverage`_ to test and measure your code.\nInstall them both:\n\n.. code-block:: none\n\n    $ pip install pytest coverage\n\n.. _pytest: https://pytest.readthedocs.io/\n.. _coverage: https://coverage.readthedocs.io/\n\n\nSetup and Fixtures\n------------------\n\nThe test code is located in the ``tests`` directory. This directory is\n*next to* the ``flaskr`` package, not inside it. The\n``tests/conftest.py`` file contains setup functions called *fixtures*\nthat each test will use. Tests are in Python modules that start with\n``test_``, and each test function in those modules also starts with\n``test_``.\n\nEach test will create a new temporary database file and populate some\ndata that will be used in the tests. Write a SQL file to insert that\ndata.\n\n.. code-block:: sql\n    :caption: ``tests/data.sql``\n\n    INSERT INTO user (username, password)\n    VALUES\n      ('test', 'pbkdf2:sha256:50000$TCI4GzcX$0de171a4f4dac32e3364c7ddc7c14f3e2fa61f2d17574483f7ffbb431b4acb2f'),\n      ('other', 'pbkdf2:sha256:50000$kJPKsz6N$d2d4784f1b030a9761f5ccaeeaca413f27f2ecb76d6168407af962ddce849f79');\n\n    INSERT INTO post (title, body, author_id, created)\n    VALUES\n      ('test title', 'test' || x'0a' || 'body', 1, '2018-01-01 00:00:00');\n\nThe ``app`` fixture will call the factory and pass ``test_config`` to\nconfigure the application and database for testing instead of using your\nlocal development configuration.\n\n.. code-block:: python\n    :caption: ``tests/conftest.py``\n\n    import os\n    import tempfile\n\n    import pytest\n    from flaskr import create_app\n    from flaskr.db import get_db, init_db\n\n    with open(os.path.join(os.path.dirname(__file__), 'data.sql'), 'rb') as f:\n        _data_sql = f.read().decode('utf8')\n\n\n    @pytest.fixture\n    def app():\n        db_fd, db_path = tempfile.mkstemp()\n\n        app = create_app({\n            'TESTING': True,\n            'DATABASE': db_path,\n        })\n\n        with app.app_context():\n            init_db()\n            get_db().executescript(_data_sql)\n\n        yield app\n\n        os.close(db_fd)\n        os.unlink(db_path)\n\n\n    @pytest.fixture\n    def client(app):\n        return app.test_client()\n\n\n    @pytest.fixture\n    def runner(app):\n        return app.test_cli_runner()\n\n:func:`tempfile.mkstemp` creates and opens a temporary file, returning\nthe file descriptor and the path to it. The ``DATABASE`` path is\noverridden so it points to this temporary path instead of the instance\nfolder. After setting the path, the database tables are created and the\ntest data is inserted. After the test is over, the temporary file is\nclosed and removed.\n\n:data:`TESTING` tells Flask that the app is in test mode. Flask changes\nsome internal behavior so it's easier to test, and other extensions can\nalso use the flag to make testing them easier.\n\nThe ``client`` fixture calls\n:meth:`app.test_client() <Flask.test_client>` with the application\nobject created by the ``app`` fixture. Tests will use the client to make\nrequests to the application without running the server.\n\nThe ``runner`` fixture is similar to ``client``.\n:meth:`app.test_cli_runner() <Flask.test_cli_runner>` creates a runner\nthat can call the Click commands registered with the application.\n\nPytest uses fixtures by matching their function names with the names\nof arguments in the test functions. For example, the ``test_hello``\nfunction you'll write next takes a ``client`` argument. Pytest matches\nthat with the ``client`` fixture function, calls it, and passes the\nreturned value to the test function.\n\n\nFactory\n-------\n\nThere's not much to test about the factory itself. Most of the code will\nbe executed for each test already, so if something fails the other tests\nwill notice.\n\nThe only behavior that can change is passing test config. If config is\nnot passed, there should be some default configuration, otherwise the\nconfiguration should be overridden.\n\n.. code-block:: python\n    :caption: ``tests/test_factory.py``\n\n    from flaskr import create_app\n\n\n    def test_config():\n        assert not create_app().testing\n        assert create_app({'TESTING': True}).testing\n\n\n    def test_hello(client):\n        response = client.get('/hello')\n        assert response.data == b'Hello, World!'\n\nYou added the ``hello`` route as an example when writing the factory at\nthe beginning of the tutorial. It returns \"Hello, World!\", so the test\nchecks that the response data matches.\n\n\nDatabase\n--------\n\nWithin an application context, ``get_db`` should return the same\nconnection each time it's called. After the context, the connection\nshould be closed.\n\n.. code-block:: python\n    :caption: ``tests/test_db.py``\n\n    import sqlite3\n\n    import pytest\n    from flaskr.db import get_db\n\n\n    def test_get_close_db(app):\n        with app.app_context():\n            db = get_db()\n            assert db is get_db()\n\n        with pytest.raises(sqlite3.ProgrammingError) as e:\n            db.execute('SELECT 1')\n\n        assert 'closed' in str(e.value)\n\nThe ``init-db`` command should call the ``init_db`` function and output\na message.\n\n.. code-block:: python\n    :caption: ``tests/test_db.py``\n\n    def test_init_db_command(runner, monkeypatch):\n        class Recorder(object):\n            called = False\n\n        def fake_init_db():\n            Recorder.called = True\n\n        monkeypatch.setattr('flaskr.db.init_db', fake_init_db)\n        result = runner.invoke(args=['init-db'])\n        assert 'Initialized' in result.output\n        assert Recorder.called\n\nThis test uses Pytest's ``monkeypatch`` fixture to replace the\n``init_db`` function with one that records that it's been called. The\n``runner`` fixture you wrote above is used to call the ``init-db``\ncommand by name.\n\n\nAuthentication\n--------------\n\nFor most of the views, a user needs to be logged in. The easiest way to\ndo this in tests is to make a ``POST`` request to the ``login`` view\nwith the client. Rather than writing that out every time, you can write\na class with methods to do that, and use a fixture to pass it the client\nfor each test.\n\n.. code-block:: python\n    :caption: ``tests/conftest.py``\n\n    class AuthActions(object):\n        def __init__(self, client):\n            self._client = client\n\n        def login(self, username='test', password='test'):\n            return self._client.post(\n                '/auth/login',\n                data={'username': username, 'password': password}\n            )\n\n        def logout(self):\n            return self._client.get('/auth/logout')\n\n\n    @pytest.fixture\n    def auth(client):\n        return AuthActions(client)\n\nWith the ``auth`` fixture, you can call ``auth.login()`` in a test to\nlog in as the ``test`` user, which was inserted as part of the test\ndata in the ``app`` fixture.\n\nThe ``register`` view should render successfully on ``GET``. On ``POST``\nwith valid form data, it should redirect to the login URL and the user's\ndata should be in the database. Invalid data should display error\nmessages.\n\n.. code-block:: python\n    :caption: ``tests/test_auth.py``\n\n    import pytest\n    from flask import g, session\n    from flaskr.db import get_db\n\n\n    def test_register(client, app):\n        assert client.get('/auth/register').status_code == 200\n        response = client.post(\n            '/auth/register', data={'username': 'a', 'password': 'a'}\n        )\n        assert response.headers[\"Location\"] == \"/auth/login\"\n\n        with app.app_context():\n            assert get_db().execute(\n                \"SELECT * FROM user WHERE username = 'a'\",\n            ).fetchone() is not None\n\n\n    @pytest.mark.parametrize(('username', 'password', 'message'), (\n        ('', '', b'Username is required.'),\n        ('a', '', b'Password is required.'),\n        ('test', 'test', b'already registered'),\n    ))\n    def test_register_validate_input(client, username, password, message):\n        response = client.post(\n            '/auth/register',\n            data={'username': username, 'password': password}\n        )\n        assert message in response.data\n\n:meth:`client.get() <werkzeug.test.Client.get>` makes a ``GET`` request\nand returns the :class:`Response` object returned by Flask. Similarly,\n:meth:`client.post() <werkzeug.test.Client.post>` makes a ``POST``\nrequest, converting the ``data`` dict into form data.\n\nTo test that the page renders successfully, a simple request is made and\nchecked for a ``200 OK`` :attr:`~Response.status_code`. If\nrendering failed, Flask would return a ``500 Internal Server Error``\ncode.\n\n:attr:`~Response.headers` will have a ``Location`` header with the login\nURL when the register view redirects to the login view.\n\n:attr:`~Response.data` contains the body of the response as bytes. If\nyou expect a certain value to render on the page, check that it's in\n``data``. Bytes must be compared to bytes. If you want to compare text,\nuse :meth:`get_data(as_text=True) <werkzeug.wrappers.Response.get_data>`\ninstead.\n\n``pytest.mark.parametrize`` tells Pytest to run the same test function\nwith different arguments. You use it here to test different invalid\ninput and error messages without writing the same code three times.\n\nThe tests for the ``login`` view are very similar to those for\n``register``. Rather than testing the data in the database,\n:data:`.session` should have ``user_id`` set after logging in.\n\n.. code-block:: python\n    :caption: ``tests/test_auth.py``\n\n    def test_login(client, auth):\n        assert client.get('/auth/login').status_code == 200\n        response = auth.login()\n        assert response.headers[\"Location\"] == \"/\"\n\n        with client:\n            client.get('/')\n            assert session['user_id'] == 1\n            assert g.user['username'] == 'test'\n\n\n    @pytest.mark.parametrize(('username', 'password', 'message'), (\n        ('a', 'test', b'Incorrect username.'),\n        ('test', 'a', b'Incorrect password.'),\n    ))\n    def test_login_validate_input(auth, username, password, message):\n        response = auth.login(username, password)\n        assert message in response.data\n\nUsing ``client`` in a ``with`` block allows accessing context variables\nsuch as :data:`.session` after the response is returned. Normally,\naccessing ``session`` outside of a request would raise an error.\n\nTesting ``logout`` is the opposite of ``login``. :data:`.session` should\nnot contain ``user_id`` after logging out.\n\n.. code-block:: python\n    :caption: ``tests/test_auth.py``\n\n    def test_logout(client, auth):\n        auth.login()\n\n        with client:\n            auth.logout()\n            assert 'user_id' not in session\n\n\nBlog\n----\n\nAll the blog views use the ``auth`` fixture you wrote earlier. Call\n``auth.login()`` and subsequent requests from the client will be logged\nin as the ``test`` user.\n\nThe ``index`` view should display information about the post that was\nadded with the test data. When logged in as the author, there should be\na link to edit the post.\n\nYou can also test some more authentication behavior while testing the\n``index`` view. When not logged in, each page shows links to log in or\nregister. When logged in, there's a link to log out.\n\n.. code-block:: python\n    :caption: ``tests/test_blog.py``\n\n    import pytest\n    from flaskr.db import get_db\n\n\n    def test_index(client, auth):\n        response = client.get('/')\n        assert b\"Log In\" in response.data\n        assert b\"Register\" in response.data\n\n        auth.login()\n        response = client.get('/')\n        assert b'Log Out' in response.data\n        assert b'test title' in response.data\n        assert b'by test on 2018-01-01' in response.data\n        assert b'test\\nbody' in response.data\n        assert b'href=\"/1/update\"' in response.data\n\nA user must be logged in to access the ``create``, ``update``, and\n``delete`` views. The logged in user must be the author of the post to\naccess ``update`` and ``delete``, otherwise a ``403 Forbidden`` status\nis returned. If a ``post`` with the given ``id`` doesn't exist,\n``update`` and ``delete`` should return ``404 Not Found``.\n\n.. code-block:: python\n    :caption: ``tests/test_blog.py``\n\n    @pytest.mark.parametrize('path', (\n        '/create',\n        '/1/update',\n        '/1/delete',\n    ))\n    def test_login_required(client, path):\n        response = client.post(path)\n        assert response.headers[\"Location\"] == \"/auth/login\"\n\n\n    def test_author_required(app, client, auth):\n        # change the post author to another user\n        with app.app_context():\n            db = get_db()\n            db.execute('UPDATE post SET author_id = 2 WHERE id = 1')\n            db.commit()\n\n        auth.login()\n        # current user can't modify other user's post\n        assert client.post('/1/update').status_code == 403\n        assert client.post('/1/delete').status_code == 403\n        # current user doesn't see edit link\n        assert b'href=\"/1/update\"' not in client.get('/').data\n\n\n    @pytest.mark.parametrize('path', (\n        '/2/update',\n        '/2/delete',\n    ))\n    def test_exists_required(client, auth, path):\n        auth.login()\n        assert client.post(path).status_code == 404\n\nThe ``create`` and ``update`` views should render and return a\n``200 OK`` status for a ``GET`` request. When valid data is sent in a\n``POST`` request, ``create`` should insert the new post data into the\ndatabase, and ``update`` should modify the existing data. Both pages\nshould show an error message on invalid data.\n\n.. code-block:: python\n    :caption: ``tests/test_blog.py``\n\n    def test_create(client, auth, app):\n        auth.login()\n        assert client.get('/create').status_code == 200\n        client.post('/create', data={'title': 'created', 'body': ''})\n\n        with app.app_context():\n            db = get_db()\n            count = db.execute('SELECT COUNT(id) FROM post').fetchone()[0]\n            assert count == 2\n\n\n    def test_update(client, auth, app):\n        auth.login()\n        assert client.get('/1/update').status_code == 200\n        client.post('/1/update', data={'title': 'updated', 'body': ''})\n\n        with app.app_context():\n            db = get_db()\n            post = db.execute('SELECT * FROM post WHERE id = 1').fetchone()\n            assert post['title'] == 'updated'\n\n\n    @pytest.mark.parametrize('path', (\n        '/create',\n        '/1/update',\n    ))\n    def test_create_update_validate(client, auth, path):\n        auth.login()\n        response = client.post(path, data={'title': '', 'body': ''})\n        assert b'Title is required.' in response.data\n\nThe ``delete`` view should redirect to the index URL and the post should\nno longer exist in the database.\n\n.. code-block:: python\n    :caption: ``tests/test_blog.py``\n\n    def test_delete(client, auth, app):\n        auth.login()\n        response = client.post('/1/delete')\n        assert response.headers[\"Location\"] == \"/\"\n\n        with app.app_context():\n            db = get_db()\n            post = db.execute('SELECT * FROM post WHERE id = 1').fetchone()\n            assert post is None\n\n\nRunning the Tests\n-----------------\n\nSome extra configuration, which is not required but makes running tests with coverage\nless verbose, can be added to the project's ``pyproject.toml`` file.\n\n.. code-block:: toml\n    :caption: ``pyproject.toml``\n\n    [tool.pytest.ini_options]\n    testpaths = [\"tests\"]\n\n    [tool.coverage.run]\n    branch = true\n    source = [\"flaskr\"]\n\nTo run the tests, use the ``pytest`` command. It will find and run all\nthe test functions you've written.\n\n.. code-block:: none\n\n    $ pytest\n\n    ========================= test session starts ==========================\n    platform linux -- Python 3.6.4, pytest-3.5.0, py-1.5.3, pluggy-0.6.0\n    rootdir: /home/user/Projects/flask-tutorial\n    collected 23 items\n\n    tests/test_auth.py ........                                      [ 34%]\n    tests/test_blog.py ............                                  [ 86%]\n    tests/test_db.py ..                                              [ 95%]\n    tests/test_factory.py ..                                         [100%]\n\n    ====================== 24 passed in 0.64 seconds =======================\n\nIf any tests fail, pytest will show the error that was raised. You can\nrun ``pytest -v`` to get a list of each test function rather than dots.\n\nTo measure the code coverage of your tests, use the ``coverage`` command\nto run pytest instead of running it directly.\n\n.. code-block:: none\n\n    $ coverage run -m pytest\n\nYou can either view a simple coverage report in the terminal:\n\n.. code-block:: none\n\n    $ coverage report\n\n    Name                 Stmts   Miss Branch BrPart  Cover\n    ------------------------------------------------------\n    flaskr/__init__.py      21      0      2      0   100%\n    flaskr/auth.py          54      0     22      0   100%\n    flaskr/blog.py          54      0     16      0   100%\n    flaskr/db.py            24      0      4      0   100%\n    ------------------------------------------------------\n    TOTAL                  153      0     44      0   100%\n\nAn HTML report allows you to see which lines were covered in each file:\n\n.. code-block:: none\n\n    $ coverage html\n\nThis generates files in the ``htmlcov`` directory. Open\n``htmlcov/index.html`` in your browser to see the report.\n\nContinue to :doc:`deploy`.\n"
    }
  },
  {
    "id": "pr-5799",
    "description": "refactor stream_with_context for async views\n\nStore the app context as well as the request context when creating the generator. This prevents the request context from automatically creating and pushing a different app context. Then push the app context first, and push them only when iteration starts, not during setup. This prevents the request context from automatically popping the app context, and avoids associating the internal ContextVar with the temporary event loop in async views.\r\n\r\nfixes #5774",
    "has_bug": false,
    "base_commit": "49b7e7bc8fb69d605719991d1c0a99fcee689053",
    "pr_url": "https://github.com/pallets/flask/pull/5799",
    "merged_at": "2025-08-19T15:23:51Z",
    "expected_files": [
      "CHANGES.rst",
      "src/flask/helpers.py",
      "tests/test_helpers.py"
    ],
    "oracle_tests": {
      "tests/test_helpers.py": "import io\nimport os\n\nimport pytest\nimport werkzeug.exceptions\n\nimport flask\nfrom flask.helpers import get_debug_flag\n\n\nclass FakePath:\n    \"\"\"Fake object to represent a ``PathLike object``.\n\n    This represents a ``pathlib.Path`` object in python 3.\n    See: https://www.python.org/dev/peps/pep-0519/\n    \"\"\"\n\n    def __init__(self, path):\n        self.path = path\n\n    def __fspath__(self):\n        return self.path\n\n\nclass PyBytesIO:\n    def __init__(self, *args, **kwargs):\n        self._io = io.BytesIO(*args, **kwargs)\n\n    def __getattr__(self, name):\n        return getattr(self._io, name)\n\n\nclass TestSendfile:\n    def test_send_file(self, app, req_ctx):\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.direct_passthrough\n        assert rv.mimetype == \"text/html\"\n\n        with app.open_resource(\"static/index.html\") as f:\n            rv.direct_passthrough = False\n            assert rv.data == f.read()\n\n        rv.close()\n\n    def test_static_file(self, app, req_ctx):\n        # Default max_age is None.\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age is None\n        rv.close()\n\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = 3600\n\n        # Test with static file handler.\n        rv = app.send_static_file(\"index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with direct use of send_file.\n        rv = flask.send_file(\"static/index.html\")\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        # Test with pathlib.Path.\n        rv = app.send_static_file(FakePath(\"index.html\"))\n        assert rv.cache_control.max_age == 3600\n        rv.close()\n\n        class StaticFileApp(flask.Flask):\n            def get_send_file_max_age(self, filename):\n                return 10\n\n        app = StaticFileApp(__name__)\n\n        with app.test_request_context():\n            # Test with static file handler.\n            rv = app.send_static_file(\"index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n            # Test with direct use of send_file.\n            rv = flask.send_file(\"static/index.html\")\n            assert rv.cache_control.max_age == 10\n            rv.close()\n\n    def test_send_from_directory(self, app, req_ctx):\n        app.root_path = os.path.join(\n            os.path.dirname(__file__), \"test_apps\", \"subdomaintestmodule\"\n        )\n        rv = flask.send_from_directory(\"static\", \"hello.txt\")\n        rv.direct_passthrough = False\n        assert rv.data.strip() == b\"Hello Subdomain\"\n        rv.close()\n\n\nclass TestUrlFor:\n    def test_url_for_with_anchor(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _anchor=\"x y\") == \"/#x%20y\"\n\n    def test_url_for_with_scheme(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https://localhost/\"\n        )\n\n    def test_url_for_with_scheme_not_external(self, app, req_ctx):\n        app.add_url_rule(\"/\", endpoint=\"index\")\n\n        # Implicit external with scheme.\n        url = flask.url_for(\"index\", _scheme=\"https\")\n        assert url == \"https://localhost/\"\n\n        # Error when external=False with scheme\n        with pytest.raises(ValueError):\n            flask.url_for(\"index\", _scheme=\"https\", _external=False)\n\n    def test_url_for_with_alternating_schemes(self, app, req_ctx):\n        @app.route(\"/\")\n        def index():\n            return \"42\"\n\n        assert flask.url_for(\"index\", _external=True) == \"http://localhost/\"\n        assert (\n            flask.url_for(\"index\", _external=True, _scheme=\"https\")\n            == \"https://localhost/\"\n        )\n        assert flask.url_for(\"index\", _external=True) == \"http://localhost/\"\n\n    def test_url_with_method(self, app, req_ctx):\n        from flask.views import MethodView\n\n        class MyView(MethodView):\n            def get(self, id=None):\n                if id is None:\n                    return \"List\"\n                return f\"Get {id:d}\"\n\n            def post(self):\n                return \"Create\"\n\n        myview = MyView.as_view(\"myview\")\n        app.add_url_rule(\"/myview/\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"/myview/<int:id>\", methods=[\"GET\"], view_func=myview)\n        app.add_url_rule(\"/myview/create\", methods=[\"POST\"], view_func=myview)\n\n        assert flask.url_for(\"myview\", _method=\"GET\") == \"/myview/\"\n        assert flask.url_for(\"myview\", id=42, _method=\"GET\") == \"/myview/42\"\n        assert flask.url_for(\"myview\", _method=\"POST\") == \"/myview/create\"\n\n    def test_url_for_with_self(self, app, req_ctx):\n        @app.route(\"/<self>\")\n        def index(self):\n            return \"42\"\n\n        assert flask.url_for(\"index\", self=\"2\") == \"/2\"\n\n\ndef test_redirect_no_app():\n    response = flask.redirect(\"https://localhost\", 307)\n    assert response.location == \"https://localhost\"\n    assert response.status_code == 307\n\n\ndef test_redirect_with_app(app):\n    def redirect(location, code=302):\n        raise ValueError\n\n    app.redirect = redirect\n\n    with app.app_context(), pytest.raises(ValueError):\n        flask.redirect(\"other\")\n\n\ndef test_abort_no_app():\n    with pytest.raises(werkzeug.exceptions.Unauthorized):\n        flask.abort(401)\n\n    with pytest.raises(LookupError):\n        flask.abort(900)\n\n\ndef test_app_aborter_class():\n    class MyAborter(werkzeug.exceptions.Aborter):\n        pass\n\n    class MyFlask(flask.Flask):\n        aborter_class = MyAborter\n\n    app = MyFlask(__name__)\n    assert isinstance(app.aborter, MyAborter)\n\n\ndef test_abort_with_app(app):\n    class My900Error(werkzeug.exceptions.HTTPException):\n        code = 900\n\n    app.aborter.mapping[900] = My900Error\n\n    with app.app_context(), pytest.raises(My900Error):\n        flask.abort(900)\n\n\nclass TestNoImports:\n    \"\"\"Test Flasks are created without import.\n\n    Avoiding ``__import__`` helps create Flask instances where there are errors\n    at import time.  Those runtime errors will be apparent to the user soon\n    enough, but tools which build Flask instances meta-programmatically benefit\n    from a Flask which does not ``__import__``.  Instead of importing to\n    retrieve file paths or metadata on a module or package, use the pkgutil and\n    imp modules in the Python standard library.\n    \"\"\"\n\n    def test_name_with_import_error(self, modules_tmp_path):\n        (modules_tmp_path / \"importerror.py\").write_text(\"raise NotImplementedError()\")\n        try:\n            flask.Flask(\"importerror\")\n        except NotImplementedError:\n            AssertionError(\"Flask(import_name) is importing import_name.\")\n\n\nclass TestStreaming:\n    def test_streaming_with_context(self, app, client):\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(generate()))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n\n    def test_streaming_with_context_as_decorator(self, app, client):\n        @app.route(\"/\")\n        def index():\n            @flask.stream_with_context\n            def generate(hello):\n                yield hello\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(generate(\"Hello \"))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n\n    def test_streaming_with_context_and_custom_close(self, app, client):\n        called = []\n\n        class Wrapper:\n            def __init__(self, gen):\n                self._gen = gen\n\n            def __iter__(self):\n                return self\n\n            def close(self):\n                called.append(42)\n\n            def __next__(self):\n                return next(self._gen)\n\n            next = __next__\n\n        @app.route(\"/\")\n        def index():\n            def generate():\n                yield \"Hello \"\n                yield flask.request.args[\"name\"]\n                yield \"!\"\n\n            return flask.Response(flask.stream_with_context(Wrapper(generate())))\n\n        rv = client.get(\"/?name=World\")\n        assert rv.data == b\"Hello World!\"\n        assert called == [42]\n\n    def test_stream_keeps_session(self, app, client):\n        @app.route(\"/\")\n        def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        rv = client.get(\"/\")\n        assert rv.data == b\"flask\"\n\n    def test_async_view(self, app, client):\n        @app.route(\"/\")\n        async def index():\n            flask.session[\"test\"] = \"flask\"\n\n            @flask.stream_with_context\n            def gen():\n                yield flask.session[\"test\"]\n\n            return flask.Response(gen())\n\n        # response is closed without reading stream\n        client.get().close()\n        # response stream is read\n        assert client.get().text == \"flask\"\n\n        # same as above, but with client context preservation\n        with client:\n            client.get().close()\n\n        with client:\n            assert client.get().text == \"flask\"\n\n\nclass TestHelpers:\n    @pytest.mark.parametrize(\n        (\"debug\", \"expect\"),\n        [\n            (\"\", False),\n            (\"0\", False),\n            (\"False\", False),\n            (\"No\", False),\n            (\"True\", True),\n        ],\n    )\n    def test_get_debug_flag(self, monkeypatch, debug, expect):\n        monkeypatch.setenv(\"FLASK_DEBUG\", debug)\n        assert get_debug_flag() == expect\n\n    def test_make_response(self):\n        app = flask.Flask(__name__)\n        with app.test_request_context():\n            rv = flask.helpers.make_response()\n            assert rv.status_code == 200\n            assert rv.mimetype == \"text/html\"\n\n            rv = flask.helpers.make_response(\"Hello\")\n            assert rv.status_code == 200\n            assert rv.data == b\"Hello\"\n            assert rv.mimetype == \"text/html\"\n\n\n@pytest.mark.parametrize(\"mode\", (\"r\", \"rb\", \"rt\"))\ndef test_open_resource(mode):\n    app = flask.Flask(__name__)\n\n    with app.open_resource(\"static/index.html\", mode) as f:\n        assert \"<h1>Hello World!</h1>\" in str(f.read())\n\n\n@pytest.mark.parametrize(\"mode\", (\"w\", \"x\", \"a\", \"r+\"))\ndef test_open_resource_exceptions(mode):\n    app = flask.Flask(__name__)\n\n    with pytest.raises(ValueError):\n        app.open_resource(\"static/index.html\", mode)\n\n\n@pytest.mark.parametrize(\"encoding\", (\"utf-8\", \"utf-16-le\"))\ndef test_open_resource_with_encoding(tmp_path, encoding):\n    app = flask.Flask(__name__, root_path=os.fspath(tmp_path))\n    (tmp_path / \"test\").write_text(\"test\", encoding=encoding)\n\n    with app.open_resource(\"test\", mode=\"rt\", encoding=encoding) as f:\n        assert f.read() == \"test\"\n"
    }
  },
  {
    "id": "pr-5736",
    "description": "support call template_filter without parens\n\nThis PR enhances the App.template_filter decorator to support:\r\n\r\n- `@app.template_filter` (without parentheses)\r\n\r\nIt also ensures that the original usage remains fully supported, with no breaking changes:\r\n\r\n- `@app.template_filter()`\r\n- `@app.template_filter(name=\"...\")`\r\n- `@app.template_filter(\"...\")`\r\n\r\nI\u2019m not fully confident in the solution, so I\u2019d like to confirm it first. If it\u2019s good, I\u2019ll apply the same change to template_global and template_test.\r\n\r\n---\r\n\r\nI considered the following implementation options:\r\n\r\n1. Rename the input parameter to func_or_name to better reflect the logic of how the input is interpreted:\r\n```\r\ndef template_filter(self, func_or_name: t.Callable[..., t.Any] | str | None = None):\r\n```\r\nHowever, this would be a breaking change for calls like @app.template_filter(name=\"...\"), so I decided to keep the original parameter name for backward compatibility.\r\n\r\n2. Make func_or_name a positional-only parameter and keep name as keyword-only:\r\n```\r\ndef template_filter(self, func_or_name: t.Callable[..., t.Any] | str | None = None, /, *, name: str | None = None):\r\n```\r\n\r\nThis approach is type-safe, but it introduces the awkward case where both func_or_name and name are provided at the same time. It could also be confusing for users reading the function signature.\r\n\r\nSo eventually, I decided to keep the original function parameter and distinguish the usage using `if callable(name):`. I\u2019d like to discuss whether there\u2019s a better approach, and I\u2019m open to making improvements based on feedback and suggestions.\r\n\r\n---\r\n\r\n\r\nfixes https://github.com/pallets/flask/issues/5729\r\n\r\n---\r\n\r\n- [x] Add tests that demonstrate the correct behavior of the change. Tests should fail without the change.\r\n- [x] Add or update relevant docs, in the docs folder and in code.\r\n- [x] Add an entry in CHANGES.rst summarizing the change and linking to the issue.\r\n- [ ] Add `.. versionchanged::` entries in any relevant code docs.\r\n",
    "has_bug": false,
    "base_commit": "85c5d93cbd049c4bd0679c36fd1ddcae8c37b642",
    "pr_url": "https://github.com/pallets/flask/pull/5736",
    "merged_at": "2025-08-19T19:36:01Z",
    "expected_files": [
      "CHANGES.rst",
      "docs/templating.rst",
      "src/flask/sansio/app.py",
      "src/flask/sansio/blueprints.py",
      "tests/test_blueprints.py",
      "tests/test_templating.py"
    ],
    "oracle_tests": {
      "tests/test_blueprints.py": "import pytest\nfrom jinja2 import TemplateNotFound\nfrom werkzeug.http import parse_cache_control_header\n\nimport flask\n\n\ndef test_blueprint_specific_error_handling(app, client):\n    frontend = flask.Blueprint(\"frontend\", __name__)\n    backend = flask.Blueprint(\"backend\", __name__)\n    sideend = flask.Blueprint(\"sideend\", __name__)\n\n    @frontend.errorhandler(403)\n    def frontend_forbidden(e):\n        return \"frontend says no\", 403\n\n    @frontend.route(\"/frontend-no\")\n    def frontend_no():\n        flask.abort(403)\n\n    @backend.errorhandler(403)\n    def backend_forbidden(e):\n        return \"backend says no\", 403\n\n    @backend.route(\"/backend-no\")\n    def backend_no():\n        flask.abort(403)\n\n    @sideend.route(\"/what-is-a-sideend\")\n    def sideend_no():\n        flask.abort(403)\n\n    app.register_blueprint(frontend)\n    app.register_blueprint(backend)\n    app.register_blueprint(sideend)\n\n    @app.errorhandler(403)\n    def app_forbidden(e):\n        return \"application itself says no\", 403\n\n    assert client.get(\"/frontend-no\").data == b\"frontend says no\"\n    assert client.get(\"/backend-no\").data == b\"backend says no\"\n    assert client.get(\"/what-is-a-sideend\").data == b\"application itself says no\"\n\n\ndef test_blueprint_specific_user_error_handling(app, client):\n    class MyDecoratorException(Exception):\n        pass\n\n    class MyFunctionException(Exception):\n        pass\n\n    blue = flask.Blueprint(\"blue\", __name__)\n\n    @blue.errorhandler(MyDecoratorException)\n    def my_decorator_exception_handler(e):\n        assert isinstance(e, MyDecoratorException)\n        return \"boom\"\n\n    def my_function_exception_handler(e):\n        assert isinstance(e, MyFunctionException)\n        return \"bam\"\n\n    blue.register_error_handler(MyFunctionException, my_function_exception_handler)\n\n    @blue.route(\"/decorator\")\n    def blue_deco_test():\n        raise MyDecoratorException()\n\n    @blue.route(\"/function\")\n    def blue_func_test():\n        raise MyFunctionException()\n\n    app.register_blueprint(blue)\n\n    assert client.get(\"/decorator\").data == b\"boom\"\n    assert client.get(\"/function\").data == b\"bam\"\n\n\ndef test_blueprint_app_error_handling(app, client):\n    errors = flask.Blueprint(\"errors\", __name__)\n\n    @errors.app_errorhandler(403)\n    def forbidden_handler(e):\n        return \"you shall not pass\", 403\n\n    @app.route(\"/forbidden\")\n    def app_forbidden():\n        flask.abort(403)\n\n    forbidden_bp = flask.Blueprint(\"forbidden_bp\", __name__)\n\n    @forbidden_bp.route(\"/nope\")\n    def bp_forbidden():\n        flask.abort(403)\n\n    app.register_blueprint(errors)\n    app.register_blueprint(forbidden_bp)\n\n    assert client.get(\"/forbidden\").data == b\"you shall not pass\"\n    assert client.get(\"/nope\").data == b\"you shall not pass\"\n\n\n@pytest.mark.parametrize(\n    (\"prefix\", \"rule\", \"url\"),\n    (\n        (\"\", \"/\", \"/\"),\n        (\"/\", \"\", \"/\"),\n        (\"/\", \"/\", \"/\"),\n        (\"/foo\", \"\", \"/foo\"),\n        (\"/foo/\", \"\", \"/foo/\"),\n        (\"\", \"/bar\", \"/bar\"),\n        (\"/foo/\", \"/bar\", \"/foo/bar\"),\n        (\"/foo/\", \"bar\", \"/foo/bar\"),\n        (\"/foo\", \"/bar\", \"/foo/bar\"),\n        (\"/foo/\", \"//bar\", \"/foo/bar\"),\n        (\"/foo//\", \"/bar\", \"/foo/bar\"),\n    ),\n)\ndef test_blueprint_prefix_slash(app, client, prefix, rule, url):\n    bp = flask.Blueprint(\"test\", __name__, url_prefix=prefix)\n\n    @bp.route(rule)\n    def index():\n        return \"\", 204\n\n    app.register_blueprint(bp)\n    assert client.get(url).status_code == 204\n\n\ndef test_blueprint_url_defaults(app, client):\n    bp = flask.Blueprint(\"test\", __name__)\n\n    @bp.route(\"/foo\", defaults={\"baz\": 42})\n    def foo(bar, baz):\n        return f\"{bar}/{baz:d}\"\n\n    @bp.route(\"/bar\")\n    def bar(bar):\n        return str(bar)\n\n    app.register_blueprint(bp, url_prefix=\"/1\", url_defaults={\"bar\": 23})\n    app.register_blueprint(bp, name=\"test2\", url_prefix=\"/2\", url_defaults={\"bar\": 19})\n\n    assert client.get(\"/1/foo\").data == b\"23/42\"\n    assert client.get(\"/2/foo\").data == b\"19/42\"\n    assert client.get(\"/1/bar\").data == b\"23\"\n    assert client.get(\"/2/bar\").data == b\"19\"\n\n\ndef test_blueprint_url_processors(app, client):\n    bp = flask.Blueprint(\"frontend\", __name__, url_prefix=\"/<lang_code>\")\n\n    @bp.url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    @bp.route(\"/\")\n    def index():\n        return flask.url_for(\".about\")\n\n    @bp.route(\"/about\")\n    def about():\n        return flask.url_for(\".index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"\n\n\ndef test_templates_and_static(test_apps):\n    from blueprintapp import app\n\n    client = app.test_client()\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"Hello from the Frontend\"\n    rv = client.get(\"/admin/\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/index2\")\n    assert rv.data == b\"Hello from the Admin\"\n    rv = client.get(\"/admin/static/test.txt\")\n    assert rv.data.strip() == b\"Admin File\"\n    rv.close()\n    rv = client.get(\"/admin/static/css/test.css\")\n    assert rv.data.strip() == b\"/* nested file */\"\n    rv.close()\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        expected_max_age = 3600\n        if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == expected_max_age:\n            expected_max_age = 7200\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = expected_max_age\n        rv = client.get(\"/admin/static/css/test.css\")\n        cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n        assert cc.max_age == expected_max_age\n        rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n    with app.test_request_context():\n        assert (\n            flask.url_for(\"admin.static\", filename=\"test.txt\")\n            == \"/admin/static/test.txt\"\n        )\n\n    with app.test_request_context():\n        with pytest.raises(TemplateNotFound) as e:\n            flask.render_template(\"missing.html\")\n        assert e.value.name == \"missing.html\"\n\n    with flask.Flask(__name__).test_request_context():\n        assert flask.render_template(\"nested/nested.txt\") == \"I'm nested\"\n\n\ndef test_default_static_max_age(app):\n    class MyBlueprint(flask.Blueprint):\n        def get_send_file_max_age(self, filename):\n            return 100\n\n    blueprint = MyBlueprint(\"blueprint\", __name__, static_folder=\"static\")\n    app.register_blueprint(blueprint)\n\n    # try/finally, in case other tests use this app for Blueprint tests.\n    max_age_default = app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"]\n    try:\n        with app.test_request_context():\n            unexpected_max_age = 3600\n            if app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] == unexpected_max_age:\n                unexpected_max_age = 7200\n            app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = unexpected_max_age\n            rv = blueprint.send_static_file(\"index.html\")\n            cc = parse_cache_control_header(rv.headers[\"Cache-Control\"])\n            assert cc.max_age == 100\n            rv.close()\n    finally:\n        app.config[\"SEND_FILE_MAX_AGE_DEFAULT\"] = max_age_default\n\n\ndef test_templates_list(test_apps):\n    from blueprintapp import app\n\n    templates = sorted(app.jinja_env.list_templates())\n    assert templates == [\"admin/index.html\", \"frontend/index.html\"]\n\n\ndef test_dotted_name_not_allowed(app, client):\n    with pytest.raises(ValueError):\n        flask.Blueprint(\"app.ui\", __name__)\n\n\ndef test_empty_name_not_allowed(app, client):\n    with pytest.raises(ValueError):\n        flask.Blueprint(\"\", __name__)\n\n\ndef test_dotted_names_from_app(app, client):\n    test = flask.Blueprint(\"test\", __name__)\n\n    @app.route(\"/\")\n    def app_index():\n        return flask.url_for(\"test.index\")\n\n    @test.route(\"/test/\")\n    def index():\n        return flask.url_for(\"app_index\")\n\n    app.register_blueprint(test)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"/test/\"\n\n\ndef test_empty_url_defaults(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/\", defaults={\"page\": 1})\n    @bp.route(\"/page/<int:page>\")\n    def something(page):\n        return str(page)\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/\").data == b\"1\"\n    assert client.get(\"/page/2\").data == b\"2\"\n\n\ndef test_route_decorator_custom_endpoint(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.route(\"/foo\")\n    def foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar\", endpoint=\"bar\")\n    def foo_bar():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/123\", endpoint=\"123\")\n    def foo_bar_foo():\n        return flask.request.endpoint\n\n    @bp.route(\"/bar/foo\")\n    def bar_foo():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    assert client.get(\"/\").data == b\"index\"\n    assert client.get(\"/py/foo\").data == b\"bp.foo\"\n    assert client.get(\"/py/bar\").data == b\"bp.bar\"\n    assert client.get(\"/py/bar/123\").data == b\"bp.123\"\n    assert client.get(\"/py/bar/foo\").data == b\"bp.bar_foo\"\n\n\ndef test_route_decorator_custom_endpoint_with_dots(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    with pytest.raises(ValueError):\n        bp.route(\"/\", endpoint=\"a.b\")(lambda: \"\")\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", endpoint=\"a.b\")\n\n    def view():\n        return \"\"\n\n    view.__name__ = \"a.b\"\n\n    with pytest.raises(ValueError):\n        bp.add_url_rule(\"/\", view_func=view)\n\n\ndef test_endpoint_decorator(app, client):\n    from werkzeug.routing import Rule\n\n    app.url_map.add(Rule(\"/foo\", endpoint=\"bar\"))\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.endpoint(\"bar\")\n    def foobar():\n        return flask.request.endpoint\n\n    app.register_blueprint(bp, url_prefix=\"/bp_prefix\")\n\n    assert client.get(\"/foo\").data == b\"bar\"\n    assert client.get(\"/bp_prefix/bar\").status_code == 404\n\n\ndef test_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    @bp.app_template_filter\n    def my_reverse_2(s):\n        return s[::-1]\n\n    @bp.app_template_filter(\"my_reverse_custom_name_3\")\n    def my_reverse_3(s):\n        return s[::-1]\n\n    @bp.app_template_filter(name=\"my_reverse_custom_name_4\")\n    def my_reverse_4(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n    assert \"my_reverse_2\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse_2\"] == my_reverse_2\n    assert app.jinja_env.filters[\"my_reverse_2\"](\"abcd\") == \"dcba\"\n\n    assert \"my_reverse_custom_name_3\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse_custom_name_3\"] == my_reverse_3\n    assert app.jinja_env.filters[\"my_reverse_custom_name_3\"](\"abcd\") == \"dcba\"\n\n    assert \"my_reverse_custom_name_4\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse_custom_name_4\"] == my_reverse_4\n    assert app.jinja_env.filters[\"my_reverse_custom_name_4\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, \"strrev\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_template_filter_after_route_with_template(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_add_template_filter_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def super_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(super_reverse)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_template_filter_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_add_template_filter_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def my_reverse(s):\n        return s[::-1]\n\n    bp.add_app_template_filter(my_reverse, \"super_reverse\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_template_test(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    @bp.app_template_test\n    def boolean_2(value):\n        return isinstance(value, bool)\n\n    @bp.app_template_test(\"my_boolean_custom_name\")\n    def boolean_3(value):\n        return isinstance(value, bool)\n\n    @bp.app_template_test(name=\"my_boolean_custom_name_2\")\n    def boolean_4(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"is_boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"is_boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"is_boolean\"](False)\n\n    assert \"boolean_2\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean_2\"] == boolean_2\n    assert app.jinja_env.tests[\"boolean_2\"](False)\n\n    assert \"my_boolean_custom_name\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"my_boolean_custom_name\"] == boolean_3\n    assert app.jinja_env.tests[\"my_boolean_custom_name\"](False)\n\n    assert \"my_boolean_custom_name_2\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"my_boolean_custom_name_2\"] == boolean_4\n    assert app.jinja_env.tests[\"my_boolean_custom_name_2\"](False)\n\n\ndef test_add_template_test(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"is_boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"is_boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"is_boolean\"](False)\n\n\ndef test_template_test_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_add_template_test_with_name(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean, \"boolean\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_template_test_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_template_test_after_route_with_template(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_test_with_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(boolean)\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_template_test_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_test_with_name_and_template(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    bp.add_app_template_test(is_boolean, \"boolean\")\n    app.register_blueprint(bp, url_prefix=\"/py\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_context_processing(app, client):\n    answer_bp = flask.Blueprint(\"answer_bp\", __name__)\n\n    def template_string():\n        return flask.render_template_string(\n            \"{% if notanswer %}{{ notanswer }} is not the answer. {% endif %}\"\n            \"{% if answer %}{{ answer }} is the answer.{% endif %}\"\n        )\n\n    # App global context processor\n    @answer_bp.app_context_processor\n    def not_answer_context_processor():\n        return {\"notanswer\": 43}\n\n    # Blueprint local context processor\n    @answer_bp.context_processor\n    def answer_context_processor():\n        return {\"answer\": 42}\n\n    # Setup endpoints for testing\n    @answer_bp.route(\"/bp\")\n    def bp_page():\n        return template_string()\n\n    @app.route(\"/\")\n    def app_page():\n        return template_string()\n\n    # Register the blueprint\n    app.register_blueprint(answer_bp)\n\n    app_page_bytes = client.get(\"/\").data\n    answer_page_bytes = client.get(\"/bp\").data\n\n    assert b\"43\" in app_page_bytes\n    assert b\"42\" not in app_page_bytes\n\n    assert b\"42\" in answer_page_bytes\n    assert b\"43\" in answer_page_bytes\n\n\ndef test_template_global(app):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    @bp.app_template_global()\n    def get_answer():\n        return 42\n\n    @bp.app_template_global\n    def get_stuff_1():\n        return \"get_stuff_1\"\n\n    @bp.app_template_global(\"my_get_stuff_custom_name_2\")\n    def get_stuff_2():\n        return \"get_stuff_2\"\n\n    @bp.app_template_global(name=\"my_get_stuff_custom_name_3\")\n    def get_stuff_3():\n        return \"get_stuff_3\"\n\n    # Make sure the function is not in the jinja_env already\n    assert \"get_answer\" not in app.jinja_env.globals.keys()\n    app.register_blueprint(bp)\n\n    # Tests\n    assert \"get_answer\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_answer\"] is get_answer\n    assert app.jinja_env.globals[\"get_answer\"]() == 42\n\n    assert \"get_stuff_1\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_stuff_1\"] == get_stuff_1\n    assert app.jinja_env.globals[\"get_stuff_1\"](), \"get_stuff_1\"\n\n    assert \"my_get_stuff_custom_name_2\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"my_get_stuff_custom_name_2\"] == get_stuff_2\n    assert app.jinja_env.globals[\"my_get_stuff_custom_name_2\"](), \"get_stuff_2\"\n\n    assert \"my_get_stuff_custom_name_3\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"my_get_stuff_custom_name_3\"] == get_stuff_3\n    assert app.jinja_env.globals[\"my_get_stuff_custom_name_3\"](), \"get_stuff_3\"\n\n    with app.app_context():\n        rv = flask.render_template_string(\"{{ get_answer() }}\")\n        assert rv == \"42\"\n\n        rv = flask.render_template_string(\"{{ get_stuff_1() }}\")\n        assert rv == \"get_stuff_1\"\n\n        rv = flask.render_template_string(\"{{ my_get_stuff_custom_name_2() }}\")\n        assert rv == \"get_stuff_2\"\n\n        rv = flask.render_template_string(\"{{ my_get_stuff_custom_name_3() }}\")\n        assert rv == \"get_stuff_3\"\n\n\ndef test_request_processing(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n    evts = []\n\n    @bp.before_request\n    def before_bp():\n        evts.append(\"before\")\n\n    @bp.after_request\n    def after_bp(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @bp.teardown_request\n    def teardown_bp(exc):\n        evts.append(\"teardown\")\n\n    # Setup routes for testing\n    @bp.route(\"/bp\")\n    def bp_endpoint():\n        return \"request\"\n\n    app.register_blueprint(bp)\n\n    assert evts == []\n    rv = client.get(\"/bp\")\n    assert rv.data == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"]\n\n\ndef test_app_request_processing(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n    evts = []\n\n    @bp.before_app_request\n    def before_app():\n        evts.append(\"before\")\n\n    @bp.after_app_request\n    def after_app(response):\n        response.data += b\"|after\"\n        evts.append(\"after\")\n        return response\n\n    @bp.teardown_app_request\n    def teardown_app(exc):\n        evts.append(\"teardown\")\n\n    app.register_blueprint(bp)\n\n    # Setup routes for testing\n    @app.route(\"/\")\n    def bp_endpoint():\n        return \"request\"\n\n    # before first request\n    assert evts == []\n\n    # first request\n    resp = client.get(\"/\").data\n    assert resp == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"]\n\n    # second request\n    resp = client.get(\"/\").data\n    assert resp == b\"request|after\"\n    assert evts == [\"before\", \"after\", \"teardown\"] * 2\n\n\ndef test_app_url_processors(app, client):\n    bp = flask.Blueprint(\"bp\", __name__)\n\n    # Register app-wide url defaults and preprocessor on blueprint\n    @bp.app_url_defaults\n    def add_language_code(endpoint, values):\n        values.setdefault(\"lang_code\", flask.g.lang_code)\n\n    @bp.app_url_value_preprocessor\n    def pull_lang_code(endpoint, values):\n        flask.g.lang_code = values.pop(\"lang_code\")\n\n    # Register route rules at the app level\n    @app.route(\"/<lang_code>/\")\n    def index():\n        return flask.url_for(\"about\")\n\n    @app.route(\"/<lang_code>/about\")\n    def about():\n        return flask.url_for(\"index\")\n\n    app.register_blueprint(bp)\n\n    assert client.get(\"/de/\").data == b\"/de/about\"\n    assert client.get(\"/de/about\").data == b\"/de/\"\n\n\ndef test_nested_blueprint(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n    grandchild = flask.Blueprint(\"grandchild\", __name__)\n\n    @parent.errorhandler(403)\n    def forbidden(e):\n        return \"Parent no\", 403\n\n    @parent.route(\"/\")\n    def parent_index():\n        return \"Parent yes\"\n\n    @parent.route(\"/no\")\n    def parent_no():\n        flask.abort(403)\n\n    @child.route(\"/\")\n    def child_index():\n        return \"Child yes\"\n\n    @child.route(\"/no\")\n    def child_no():\n        flask.abort(403)\n\n    @grandchild.errorhandler(403)\n    def grandchild_forbidden(e):\n        return \"Grandchild no\", 403\n\n    @grandchild.route(\"/\")\n    def grandchild_index():\n        return \"Grandchild yes\"\n\n    @grandchild.route(\"/no\")\n    def grandchild_no():\n        flask.abort(403)\n\n    child.register_blueprint(grandchild, url_prefix=\"/grandchild\")\n    parent.register_blueprint(child, url_prefix=\"/child\")\n    app.register_blueprint(parent, url_prefix=\"/parent\")\n\n    assert client.get(\"/parent/\").data == b\"Parent yes\"\n    assert client.get(\"/parent/child/\").data == b\"Child yes\"\n    assert client.get(\"/parent/child/grandchild/\").data == b\"Grandchild yes\"\n    assert client.get(\"/parent/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/no\").data == b\"Parent no\"\n    assert client.get(\"/parent/child/grandchild/no\").data == b\"Grandchild no\"\n\n\ndef test_nested_callback_order(app, client):\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n\n    @app.before_request\n    def app_before1():\n        flask.g.setdefault(\"seen\", []).append(\"app_1\")\n\n    @app.teardown_request\n    def app_teardown1(e=None):\n        assert flask.g.seen.pop() == \"app_1\"\n\n    @app.before_request\n    def app_before2():\n        flask.g.setdefault(\"seen\", []).append(\"app_2\")\n\n    @app.teardown_request\n    def app_teardown2(e=None):\n        assert flask.g.seen.pop() == \"app_2\"\n\n    @app.context_processor\n    def app_ctx():\n        return dict(key=\"app\")\n\n    @parent.before_request\n    def parent_before1():\n        flask.g.setdefault(\"seen\", []).append(\"parent_1\")\n\n    @parent.teardown_request\n    def parent_teardown1(e=None):\n        assert flask.g.seen.pop() == \"parent_1\"\n\n    @parent.before_request\n    def parent_before2():\n        flask.g.setdefault(\"seen\", []).append(\"parent_2\")\n\n    @parent.teardown_request\n    def parent_teardown2(e=None):\n        assert flask.g.seen.pop() == \"parent_2\"\n\n    @parent.context_processor\n    def parent_ctx():\n        return dict(key=\"parent\")\n\n    @child.before_request\n    def child_before1():\n        flask.g.setdefault(\"seen\", []).append(\"child_1\")\n\n    @child.teardown_request\n    def child_teardown1(e=None):\n        assert flask.g.seen.pop() == \"child_1\"\n\n    @child.before_request\n    def child_before2():\n        flask.g.setdefault(\"seen\", []).append(\"child_2\")\n\n    @child.teardown_request\n    def child_teardown2(e=None):\n        assert flask.g.seen.pop() == \"child_2\"\n\n    @child.context_processor\n    def child_ctx():\n        return dict(key=\"child\")\n\n    @child.route(\"/a\")\n    def a():\n        return \", \".join(flask.g.seen)\n\n    @child.route(\"/b\")\n    def b():\n        return flask.render_template_string(\"{{ key }}\")\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent)\n    assert (\n        client.get(\"/a\").data == b\"app_1, app_2, parent_1, parent_2, child_1, child_2\"\n    )\n    assert client.get(\"/b\").data == b\"child\"\n\n\n@pytest.mark.parametrize(\n    \"parent_init, child_init, parent_registration, child_registration\",\n    [\n        (\"/parent\", \"/child\", None, None),\n        (\"/parent\", None, None, \"/child\"),\n        (None, None, \"/parent\", \"/child\"),\n        (\"/other\", \"/something\", \"/parent\", \"/child\"),\n    ],\n)\ndef test_nesting_url_prefixes(\n    parent_init,\n    child_init,\n    parent_registration,\n    child_registration,\n    app,\n    client,\n) -> None:\n    parent = flask.Blueprint(\"parent\", __name__, url_prefix=parent_init)\n    child = flask.Blueprint(\"child\", __name__, url_prefix=child_init)\n\n    @child.route(\"/\")\n    def index():\n        return \"index\"\n\n    parent.register_blueprint(child, url_prefix=child_registration)\n    app.register_blueprint(parent, url_prefix=parent_registration)\n\n    response = client.get(\"/parent/child/\")\n    assert response.status_code == 200\n\n\ndef test_nesting_subdomains(app, client) -> None:\n    app.subdomain_matching = True\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n    client.allow_subdomain_redirects = True\n\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__)\n\n    @child.route(\"/child/\")\n    def index():\n        return \"child\"\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent, subdomain=\"api\")\n\n    response = client.get(\"/child/\", base_url=\"http://api.example.test\")\n    assert response.status_code == 200\n\n\ndef test_child_and_parent_subdomain(app, client) -> None:\n    app.subdomain_matching = True\n    app.config[\"SERVER_NAME\"] = \"example.test\"\n    client.allow_subdomain_redirects = True\n\n    parent = flask.Blueprint(\"parent\", __name__)\n    child = flask.Blueprint(\"child\", __name__, subdomain=\"api\")\n\n    @child.route(\"/\")\n    def index():\n        return \"child\"\n\n    parent.register_blueprint(child)\n    app.register_blueprint(parent, subdomain=\"parent\")\n\n    response = client.get(\"/\", base_url=\"http://api.parent.example.test\")\n    assert response.status_code == 200\n\n    response = client.get(\"/\", base_url=\"http://parent.example.test\")\n    assert response.status_code == 404\n\n\ndef test_unique_blueprint_names(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp\", __name__)\n\n    app.register_blueprint(bp)\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp)  # same bp, same name, error\n\n    app.register_blueprint(bp, name=\"again\")  # same bp, different name, ok\n\n    with pytest.raises(ValueError):\n        app.register_blueprint(bp2)  # different bp, same name, error\n\n    app.register_blueprint(bp2, name=\"alt\")  # different bp, different name, ok\n\n\ndef test_self_registration(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    with pytest.raises(ValueError):\n        bp.register_blueprint(bp)\n\n\ndef test_blueprint_renaming(app, client) -> None:\n    bp = flask.Blueprint(\"bp\", __name__)\n    bp2 = flask.Blueprint(\"bp2\", __name__)\n\n    @bp.get(\"/\")\n    def index():\n        return flask.request.endpoint\n\n    @bp.get(\"/error\")\n    def error():\n        flask.abort(403)\n\n    @bp.errorhandler(403)\n    def forbidden(_: Exception):\n        return \"Error\", 403\n\n    @bp2.get(\"/\")\n    def index2():\n        return flask.request.endpoint\n\n    bp.register_blueprint(bp2, url_prefix=\"/a\", name=\"sub\")\n    app.register_blueprint(bp, url_prefix=\"/a\")\n    app.register_blueprint(bp, url_prefix=\"/b\", name=\"alt\")\n\n    assert client.get(\"/a/\").data == b\"bp.index\"\n    assert client.get(\"/b/\").data == b\"alt.index\"\n    assert client.get(\"/a/a/\").data == b\"bp.sub.index2\"\n    assert client.get(\"/b/a/\").data == b\"alt.sub.index2\"\n    assert client.get(\"/a/error\").data == b\"Error\"\n    assert client.get(\"/b/error\").data == b\"Error\"\n",
      "tests/test_templating.py": "import logging\n\nimport pytest\nimport werkzeug.serving\nfrom jinja2 import TemplateNotFound\nfrom markupsafe import Markup\n\nimport flask\n\n\ndef test_context_processing(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"injected_value\": 42}\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"context_template.html\", value=23)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"<p>23|42\"\n\n\ndef test_original_win(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.render_template_string(\"{{ config }}\", config=42)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"\n\n\ndef test_simple_stream(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.stream_template_string(\"{{ config }}\", config=42)\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"42\"\n\n\ndef test_request_less_rendering(app, app_ctx):\n    app.config[\"WORLD_NAME\"] = \"Special World\"\n\n    @app.context_processor\n    def context_processor():\n        return dict(foo=42)\n\n    rv = flask.render_template_string(\"Hello {{ config.WORLD_NAME }} {{ foo }}\")\n    assert rv == \"Hello Special World 42\"\n\n\ndef test_standard_context(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.g.foo = 23\n        flask.session[\"test\"] = \"aha\"\n        return flask.render_template_string(\n            \"\"\"\n            {{ request.args.foo }}\n            {{ g.foo }}\n            {{ config.DEBUG }}\n            {{ session.test }}\n        \"\"\"\n        )\n\n    rv = client.get(\"/?foo=42\")\n    assert rv.data.split() == [b\"42\", b\"23\", b\"False\", b\"aha\"]\n\n\ndef test_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            \"escaping_template.html\", text=text, html=Markup(text)\n        )\n\n    lines = client.get(\"/\").data.splitlines()\n    assert lines == [\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n    ]\n\n\ndef test_no_escaping(app, client):\n    text = \"<p>Hello World!\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            \"non_escaping_template.txt\", text=text, html=Markup(text)\n        )\n\n    lines = client.get(\"/\").data.splitlines()\n    assert lines == [\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"&lt;p&gt;Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n        b\"<p>Hello World!\",\n    ]\n\n\ndef test_escaping_without_template_filename(app, client, req_ctx):\n    assert flask.render_template_string(\"{{ foo }}\", foo=\"<test>\") == \"&lt;test&gt;\"\n    assert flask.render_template(\"mail.txt\", foo=\"<test>\") == \"<test> Mail\"\n\n\ndef test_macros(app, req_ctx):\n    macro = flask.get_template_attribute(\"_macro.html\", \"hello\")\n    assert macro(\"World\") == \"Hello World!\"\n\n\ndef test_template_filter(app):\n    @app.template_filter()\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n    @app.template_filter\n    def my_reverse_2(s):\n        return s[::-1]\n\n    assert \"my_reverse_2\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse_2\"] == my_reverse_2\n    assert app.jinja_env.filters[\"my_reverse_2\"](\"abcd\") == \"dcba\"\n\n    @app.template_filter(\"my_reverse_custom_name_3\")\n    def my_reverse_3(s):\n        return s[::-1]\n\n    assert \"my_reverse_custom_name_3\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse_custom_name_3\"] == my_reverse_3\n    assert app.jinja_env.filters[\"my_reverse_custom_name_3\"](\"abcd\") == \"dcba\"\n\n    @app.template_filter(name=\"my_reverse_custom_name_4\")\n    def my_reverse_4(s):\n        return s[::-1]\n\n    assert \"my_reverse_custom_name_4\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse_custom_name_4\"] == my_reverse_4\n    assert app.jinja_env.filters[\"my_reverse_custom_name_4\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse)\n    assert \"my_reverse\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"my_reverse\"] == my_reverse\n    assert app.jinja_env.filters[\"my_reverse\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_name(app):\n    @app.template_filter(\"strrev\")\n    def my_reverse(s):\n        return s[::-1]\n\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_add_template_filter_with_name(app):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"strrev\")\n    assert \"strrev\" in app.jinja_env.filters.keys()\n    assert app.jinja_env.filters[\"strrev\"] == my_reverse\n    assert app.jinja_env.filters[\"strrev\"](\"abcd\") == \"dcba\"\n\n\ndef test_template_filter_with_template(app, client):\n    @app.template_filter()\n    def super_reverse(s):\n        return s[::-1]\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_add_template_filter_with_template(app, client):\n    def super_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(super_reverse)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_template_filter_with_name_and_template(app, client):\n    @app.template_filter(\"super_reverse\")\n    def my_reverse(s):\n        return s[::-1]\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_add_template_filter_with_name_and_template(app, client):\n    def my_reverse(s):\n        return s[::-1]\n\n    app.add_template_filter(my_reverse, \"super_reverse\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_filter.html\", value=\"abcd\")\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"dcba\"\n\n\ndef test_template_test(app):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n    @app.template_test\n    def boolean_2(value):\n        return isinstance(value, bool)\n\n    assert \"boolean_2\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean_2\"] == boolean_2\n    assert app.jinja_env.tests[\"boolean_2\"](False)\n\n    @app.template_test(\"my_boolean_custom_name\")\n    def boolean_3(value):\n        return isinstance(value, bool)\n\n    assert \"my_boolean_custom_name\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"my_boolean_custom_name\"] == boolean_3\n    assert app.jinja_env.tests[\"my_boolean_custom_name\"](False)\n\n    @app.template_test(name=\"my_boolean_custom_name_2\")\n    def boolean_4(value):\n        return isinstance(value, bool)\n\n    assert \"my_boolean_custom_name_2\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"my_boolean_custom_name_2\"] == boolean_4\n    assert app.jinja_env.tests[\"my_boolean_custom_name_2\"](False)\n\n\ndef test_add_template_test(app):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_template_test_with_name(app):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_add_template_test_with_name(app):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n    assert \"boolean\" in app.jinja_env.tests.keys()\n    assert app.jinja_env.tests[\"boolean\"] == is_boolean\n    assert app.jinja_env.tests[\"boolean\"](False)\n\n\ndef test_template_test_with_template(app, client):\n    @app.template_test()\n    def boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_test_with_template(app, client):\n    def boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(boolean)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_template_test_with_name_and_template(app, client):\n    @app.template_test(\"boolean\")\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_test_with_name_and_template(app, client):\n    def is_boolean(value):\n        return isinstance(value, bool)\n\n    app.add_template_test(is_boolean, \"boolean\")\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"template_test.html\", value=False)\n\n    rv = client.get(\"/\")\n    assert b\"Success!\" in rv.data\n\n\ndef test_add_template_global(app, app_ctx):\n    @app.template_global()\n    def get_stuff():\n        return 42\n\n    assert \"get_stuff\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_stuff\"] == get_stuff\n    assert app.jinja_env.globals[\"get_stuff\"](), 42\n\n    rv = flask.render_template_string(\"{{ get_stuff() }}\")\n    assert rv == \"42\"\n\n    @app.template_global\n    def get_stuff_1():\n        return \"get_stuff_1\"\n\n    assert \"get_stuff_1\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"get_stuff_1\"] == get_stuff_1\n    assert app.jinja_env.globals[\"get_stuff_1\"](), \"get_stuff_1\"\n\n    rv = flask.render_template_string(\"{{ get_stuff_1() }}\")\n    assert rv == \"get_stuff_1\"\n\n    @app.template_global(\"my_get_stuff_custom_name_2\")\n    def get_stuff_2():\n        return \"get_stuff_2\"\n\n    assert \"my_get_stuff_custom_name_2\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"my_get_stuff_custom_name_2\"] == get_stuff_2\n    assert app.jinja_env.globals[\"my_get_stuff_custom_name_2\"](), \"get_stuff_2\"\n\n    rv = flask.render_template_string(\"{{ my_get_stuff_custom_name_2() }}\")\n    assert rv == \"get_stuff_2\"\n\n    @app.template_global(name=\"my_get_stuff_custom_name_3\")\n    def get_stuff_3():\n        return \"get_stuff_3\"\n\n    assert \"my_get_stuff_custom_name_3\" in app.jinja_env.globals.keys()\n    assert app.jinja_env.globals[\"my_get_stuff_custom_name_3\"] == get_stuff_3\n    assert app.jinja_env.globals[\"my_get_stuff_custom_name_3\"](), \"get_stuff_3\"\n\n    rv = flask.render_template_string(\"{{ my_get_stuff_custom_name_3() }}\")\n    assert rv == \"get_stuff_3\"\n\n\ndef test_custom_template_loader(client):\n    class MyFlask(flask.Flask):\n        def create_global_jinja_loader(self):\n            from jinja2 import DictLoader\n\n            return DictLoader({\"index.html\": \"Hello Custom World!\"})\n\n    app = MyFlask(__name__)\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\"index.html\")\n\n    c = app.test_client()\n    rv = c.get(\"/\")\n    assert rv.data == b\"Hello Custom World!\"\n\n\ndef test_iterable_loader(app, client):\n    @app.context_processor\n    def context_processor():\n        return {\"whiskey\": \"Jameson\"}\n\n    @app.route(\"/\")\n    def index():\n        return flask.render_template(\n            [\n                \"no_template.xml\",  # should skip this one\n                \"simple_template.html\",  # should render this\n                \"context_template.html\",\n            ],\n            value=23,\n        )\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"<h1>Jameson</h1>\"\n\n\ndef test_templates_auto_reload(app):\n    # debug is False, config option is None\n    assert app.debug is False\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is False\n    # debug is False, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.debug is False\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is None\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    assert app.config[\"TEMPLATES_AUTO_RELOAD\"] is None\n    assert app.jinja_env.auto_reload is True\n    # debug is True, config option is False\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = False\n    assert app.jinja_env.auto_reload is False\n    # debug is True, config option is True\n    app = flask.Flask(__name__)\n    app.config[\"DEBUG\"] = True\n    app.config[\"TEMPLATES_AUTO_RELOAD\"] = True\n    assert app.jinja_env.auto_reload is True\n\n\ndef test_templates_auto_reload_debug_run(app, monkeypatch):\n    def run_simple_mock(*args, **kwargs):\n        pass\n\n    monkeypatch.setattr(werkzeug.serving, \"run_simple\", run_simple_mock)\n\n    app.run()\n    assert not app.jinja_env.auto_reload\n\n    app.run(debug=True)\n    assert app.jinja_env.auto_reload\n\n\ndef test_template_loader_debugging(test_apps, monkeypatch):\n    from blueprintapp import app\n\n    called = []\n\n    class _TestHandler(logging.Handler):\n        def handle(self, record):\n            called.append(True)\n            text = str(record.msg)\n            assert \"1: trying loader of application 'blueprintapp'\" in text\n            assert (\n                \"2: trying loader of blueprint 'admin' (blueprintapp.apps.admin)\"\n            ) in text\n            assert (\n                \"trying loader of blueprint 'frontend' (blueprintapp.apps.frontend)\"\n            ) in text\n            assert \"Error: the template could not be found\" in text\n            assert (\n                \"looked up from an endpoint that belongs to the blueprint 'frontend'\"\n            ) in text\n            assert \"See https://flask.palletsprojects.com/blueprints/#templates\" in text\n\n    with app.test_client() as c:\n        monkeypatch.setitem(app.config, \"EXPLAIN_TEMPLATE_LOADING\", True)\n        monkeypatch.setattr(\n            logging.getLogger(\"blueprintapp\"), \"handlers\", [_TestHandler()]\n        )\n\n        with pytest.raises(TemplateNotFound) as excinfo:\n            c.get(\"/missing\")\n\n        assert \"missing_template.html\" in str(excinfo.value)\n\n    assert len(called) == 1\n\n\ndef test_custom_jinja_env():\n    class CustomEnvironment(flask.templating.Environment):\n        pass\n\n    class CustomFlask(flask.Flask):\n        jinja_environment = CustomEnvironment\n\n    app = CustomFlask(__name__)\n    assert isinstance(app.jinja_env, CustomEnvironment)\n"
    }
  },
  {
    "id": "pr-5795",
    "description": "Update GitHub Actions workflow for artifact handling\n\n## Use `artifact-id` instead of (default assumed) `name` with Actions Artifacts \ud83d\udd12 \r\n\r\nThis pull updates the **publish** workflow to use `artifact-id` instead of the default assumed `name` (in this case the literal word `artifact`) when downloading artifacts that have been previously published in prior workflow steps. This is important because artifacts produced by GitHub Actions can be completely overwritten by other workflow runs if they use the same `name` under very unique circumstances (like passing the `run-id` value to the download-artifact action to point to an entirely different workflow run - don't do that). To avoid potential TOCTOU issues/vulnerabilities where an artifact might be replaced between upload and download, the new `artifact-ids` input allows you to download artifacts by their specific ID rather than by name. This is safer but also helps lead to more deterministic workflow builds by referencing the artifact you wish to download by its _exact id_.\r\n\r\nThis PR also hardens the workflow a bit by adding `persist-credentials: false` to the checkout step.\r\n\r\n---\r\n\r\nI recently did some work to land these exact changes in the [urllib3/urllib3](https://github.com/urllib3/urllib3/pulls?q=is%3Apr+is%3Aclosed+author%3AGrantBirki) and wanted to contribute those same changes here as well! Also recently made updates to Python's [requests](https://github.com/psf/requests/pull/7005) library to do the same.",
    "has_bug": false,
    "base_commit": "55c62556571ee46a94da174643b50ece06edead4",
    "pr_url": "https://github.com/pallets/flask/pull/5795",
    "merged_at": "2025-08-19T20:56:49Z",
    "expected_files": [
      ".github/workflows/publish.yaml"
    ],
    "oracle_tests": {}
  },
  {
    "id": "pr-5800",
    "description": "release version 3.1.2\n\n",
    "has_bug": false,
    "base_commit": "1292419ddfc6a14fc7f85b5ed7efcc2d215f1ad3",
    "pr_url": "https://github.com/pallets/flask/pull/5800",
    "merged_at": "2025-08-19T21:03:43Z",
    "expected_files": [
      "CHANGES.rst",
      "pyproject.toml",
      "uv.lock"
    ],
    "oracle_tests": {}
  },
  {
    "id": "pr-5797",
    "description": "push preserved contexts in correct order\n\nThe test client asks the app to append contexts to a stack, in order to re-push them when using `with client`. However, they were being pushed in reverse order, resulting in the oldest context being seen as current. This PR pushes them in the correct order, meaning `session` will be in the correct state of the last response.\r\n\r\nfixes #5786 ",
    "has_bug": false,
    "base_commit": "5addaf833b2e8c7a616f89dd8ad5a44b07d7c000",
    "pr_url": "https://github.com/pallets/flask/pull/5797",
    "merged_at": "2025-08-18T16:56:39Z",
    "expected_files": [
      "CHANGES.rst",
      "src/flask/testing.py",
      "tests/test_testing.py"
    ],
    "oracle_tests": {
      "src/flask/testing.py": "from __future__ import annotations\n\nimport importlib.metadata\nimport typing as t\nfrom contextlib import contextmanager\nfrom contextlib import ExitStack\nfrom copy import copy\nfrom types import TracebackType\nfrom urllib.parse import urlsplit\n\nimport werkzeug.test\nfrom click.testing import CliRunner\nfrom click.testing import Result\nfrom werkzeug.test import Client\nfrom werkzeug.wrappers import Request as BaseRequest\n\nfrom .cli import ScriptInfo\nfrom .sessions import SessionMixin\n\nif t.TYPE_CHECKING:  # pragma: no cover\n    from _typeshed.wsgi import WSGIEnvironment\n    from werkzeug.test import TestResponse\n\n    from .app import Flask\n\n\nclass EnvironBuilder(werkzeug.test.EnvironBuilder):\n    \"\"\"An :class:`~werkzeug.test.EnvironBuilder`, that takes defaults from the\n    application.\n\n    :param app: The Flask application to configure the environment from.\n    :param path: URL path being requested.\n    :param base_url: Base URL where the app is being served, which\n        ``path`` is relative to. If not given, built from\n        :data:`PREFERRED_URL_SCHEME`, ``subdomain``,\n        :data:`SERVER_NAME`, and :data:`APPLICATION_ROOT`.\n    :param subdomain: Subdomain name to append to :data:`SERVER_NAME`.\n    :param url_scheme: Scheme to use instead of\n        :data:`PREFERRED_URL_SCHEME`.\n    :param json: If given, this is serialized as JSON and passed as\n        ``data``. Also defaults ``content_type`` to\n        ``application/json``.\n    :param args: other positional arguments passed to\n        :class:`~werkzeug.test.EnvironBuilder`.\n    :param kwargs: other keyword arguments passed to\n        :class:`~werkzeug.test.EnvironBuilder`.\n    \"\"\"\n\n    def __init__(\n        self,\n        app: Flask,\n        path: str = \"/\",\n        base_url: str | None = None,\n        subdomain: str | None = None,\n        url_scheme: str | None = None,\n        *args: t.Any,\n        **kwargs: t.Any,\n    ) -> None:\n        assert not (base_url or subdomain or url_scheme) or (\n            base_url is not None\n        ) != bool(subdomain or url_scheme), (\n            'Cannot pass \"subdomain\" or \"url_scheme\" with \"base_url\".'\n        )\n\n        if base_url is None:\n            http_host = app.config.get(\"SERVER_NAME\") or \"localhost\"\n            app_root = app.config[\"APPLICATION_ROOT\"]\n\n            if subdomain:\n                http_host = f\"{subdomain}.{http_host}\"\n\n            if url_scheme is None:\n                url_scheme = app.config[\"PREFERRED_URL_SCHEME\"]\n\n            url = urlsplit(path)\n            base_url = (\n                f\"{url.scheme or url_scheme}://{url.netloc or http_host}\"\n                f\"/{app_root.lstrip('/')}\"\n            )\n            path = url.path\n\n            if url.query:\n                path = f\"{path}?{url.query}\"\n\n        self.app = app\n        super().__init__(path, base_url, *args, **kwargs)\n\n    def json_dumps(self, obj: t.Any, **kwargs: t.Any) -> str:\n        \"\"\"Serialize ``obj`` to a JSON-formatted string.\n\n        The serialization will be configured according to the config associated\n        with this EnvironBuilder's ``app``.\n        \"\"\"\n        return self.app.json.dumps(obj, **kwargs)\n\n\n_werkzeug_version = \"\"\n\n\ndef _get_werkzeug_version() -> str:\n    global _werkzeug_version\n\n    if not _werkzeug_version:\n        _werkzeug_version = importlib.metadata.version(\"werkzeug\")\n\n    return _werkzeug_version\n\n\nclass FlaskClient(Client):\n    \"\"\"Works like a regular Werkzeug test client but has knowledge about\n    Flask's contexts to defer the cleanup of the request context until\n    the end of a ``with`` block. For general information about how to\n    use this class refer to :class:`werkzeug.test.Client`.\n\n    .. versionchanged:: 0.12\n       `app.test_client()` includes preset default environment, which can be\n       set after instantiation of the `app.test_client()` object in\n       `client.environ_base`.\n\n    Basic usage is outlined in the :doc:`/testing` chapter.\n    \"\"\"\n\n    application: Flask\n\n    def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:\n        super().__init__(*args, **kwargs)\n        self.preserve_context = False\n        self._new_contexts: list[t.ContextManager[t.Any]] = []\n        self._context_stack = ExitStack()\n        self.environ_base = {\n            \"REMOTE_ADDR\": \"127.0.0.1\",\n            \"HTTP_USER_AGENT\": f\"Werkzeug/{_get_werkzeug_version()}\",\n        }\n\n    @contextmanager\n    def session_transaction(\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.Iterator[SessionMixin]:\n        \"\"\"When used in combination with a ``with`` statement this opens a\n        session transaction.  This can be used to modify the session that\n        the test client uses.  Once the ``with`` block is left the session is\n        stored back.\n\n        ::\n\n            with client.session_transaction() as session:\n                session['value'] = 42\n\n        Internally this is implemented by going through a temporary test\n        request context and since session handling could depend on\n        request variables this function accepts the same arguments as\n        :meth:`~flask.Flask.test_request_context` which are directly\n        passed through.\n        \"\"\"\n        if self._cookies is None:\n            raise TypeError(\n                \"Cookies are disabled. Create a client with 'use_cookies=True'.\"\n            )\n\n        app = self.application\n        ctx = app.test_request_context(*args, **kwargs)\n        self._add_cookies_to_wsgi(ctx.request.environ)\n\n        with ctx:\n            sess = app.session_interface.open_session(app, ctx.request)\n\n        if sess is None:\n            raise RuntimeError(\"Session backend did not open a session.\")\n\n        yield sess\n        resp = app.response_class()\n\n        if app.session_interface.is_null_session(sess):\n            return\n\n        with ctx:\n            app.session_interface.save_session(app, sess, resp)\n\n        self._update_cookies_from_response(\n            ctx.request.host.partition(\":\")[0],\n            ctx.request.path,\n            resp.headers.getlist(\"Set-Cookie\"),\n        )\n\n    def _copy_environ(self, other: WSGIEnvironment) -> WSGIEnvironment:\n        out = {**self.environ_base, **other}\n\n        if self.preserve_context:\n            out[\"werkzeug.debug.preserve_context\"] = self._new_contexts.append\n\n        return out\n\n    def _request_from_builder_args(\n        self, args: tuple[t.Any, ...], kwargs: dict[str, t.Any]\n    ) -> BaseRequest:\n        kwargs[\"environ_base\"] = self._copy_environ(kwargs.get(\"environ_base\", {}))\n        builder = EnvironBuilder(self.application, *args, **kwargs)\n\n        try:\n            return builder.get_request()\n        finally:\n            builder.close()\n\n    def open(\n        self,\n        *args: t.Any,\n        buffered: bool = False,\n        follow_redirects: bool = False,\n        **kwargs: t.Any,\n    ) -> TestResponse:\n        if args and isinstance(\n            args[0], (werkzeug.test.EnvironBuilder, dict, BaseRequest)\n        ):\n            if isinstance(args[0], werkzeug.test.EnvironBuilder):\n                builder = copy(args[0])\n                builder.environ_base = self._copy_environ(builder.environ_base or {})  # type: ignore[arg-type]\n                request = builder.get_request()\n            elif isinstance(args[0], dict):\n                request = EnvironBuilder.from_environ(\n                    args[0], app=self.application, environ_base=self._copy_environ({})\n                ).get_request()\n            else:\n                # isinstance(args[0], BaseRequest)\n                request = copy(args[0])\n                request.environ = self._copy_environ(request.environ)\n        else:\n            # request is None\n            request = self._request_from_builder_args(args, kwargs)\n\n        # Pop any previously preserved contexts. This prevents contexts\n        # from being preserved across redirects or multiple requests\n        # within a single block.\n        self._context_stack.close()\n\n        response = super().open(\n            request,\n            buffered=buffered,\n            follow_redirects=follow_redirects,\n        )\n        response.json_module = self.application.json  # type: ignore[assignment]\n\n        # Re-push contexts that were preserved during the request.\n        for cm in self._new_contexts:\n            self._context_stack.enter_context(cm)\n\n        self._new_contexts.clear()\n        return response\n\n    def __enter__(self) -> FlaskClient:\n        if self.preserve_context:\n            raise RuntimeError(\"Cannot nest client invocations\")\n        self.preserve_context = True\n        return self\n\n    def __exit__(\n        self,\n        exc_type: type | None,\n        exc_value: BaseException | None,\n        tb: TracebackType | None,\n    ) -> None:\n        self.preserve_context = False\n        self._context_stack.close()\n\n\nclass FlaskCliRunner(CliRunner):\n    \"\"\"A :class:`~click.testing.CliRunner` for testing a Flask app's\n    CLI commands. Typically created using\n    :meth:`~flask.Flask.test_cli_runner`. See :ref:`testing-cli`.\n    \"\"\"\n\n    def __init__(self, app: Flask, **kwargs: t.Any) -> None:\n        self.app = app\n        super().__init__(**kwargs)\n\n    def invoke(  # type: ignore\n        self, cli: t.Any = None, args: t.Any = None, **kwargs: t.Any\n    ) -> Result:\n        \"\"\"Invokes a CLI command in an isolated environment. See\n        :meth:`CliRunner.invoke <click.testing.CliRunner.invoke>` for\n        full method documentation. See :ref:`testing-cli` for examples.\n\n        If the ``obj`` argument is not given, passes an instance of\n        :class:`~flask.cli.ScriptInfo` that knows how to load the Flask\n        app being tested.\n\n        :param cli: Command object to invoke. Default is the app's\n            :attr:`~flask.app.Flask.cli` group.\n        :param args: List of strings to invoke the command with.\n\n        :return: a :class:`~click.testing.Result` object.\n        \"\"\"\n        if cli is None:\n            cli = self.app.cli\n\n        if \"obj\" not in kwargs:\n            kwargs[\"obj\"] = ScriptInfo(create_app=lambda: self.app)\n\n        return super().invoke(cli, args, **kwargs)\n",
      "tests/test_testing.py": "import importlib.metadata\n\nimport click\nimport pytest\n\nimport flask\nfrom flask import appcontext_popped\nfrom flask.cli import ScriptInfo\nfrom flask.globals import _cv_request\nfrom flask.json import jsonify\nfrom flask.testing import EnvironBuilder\nfrom flask.testing import FlaskCliRunner\n\n\ndef test_environ_defaults_from_config(app, client):\n    app.config[\"SERVER_NAME\"] = \"example.com:1234\"\n    app.config[\"APPLICATION_ROOT\"] = \"/foo\"\n\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context()\n    assert ctx.request.url == \"http://example.com:1234/foo/\"\n\n    rv = client.get(\"/\")\n    assert rv.data == b\"http://example.com:1234/foo/\"\n\n\ndef test_environ_defaults(app, client, app_ctx, req_ctx):\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context()\n    assert ctx.request.url == \"http://localhost/\"\n    with client:\n        rv = client.get(\"/\")\n        assert rv.data == b\"http://localhost/\"\n\n\ndef test_environ_base_default(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.g.remote_addr = flask.request.remote_addr\n        flask.g.user_agent = flask.request.user_agent.string\n        return \"\"\n\n    with client:\n        client.get(\"/\")\n        assert flask.g.remote_addr == \"127.0.0.1\"\n        assert flask.g.user_agent == (\n            f\"Werkzeug/{importlib.metadata.version('werkzeug')}\"\n        )\n\n\ndef test_environ_base_modified(app, client):\n    @app.route(\"/\")\n    def index():\n        flask.g.remote_addr = flask.request.remote_addr\n        flask.g.user_agent = flask.request.user_agent.string\n        return \"\"\n\n    client.environ_base[\"REMOTE_ADDR\"] = \"192.168.0.22\"\n    client.environ_base[\"HTTP_USER_AGENT\"] = \"Foo\"\n\n    with client:\n        client.get(\"/\")\n        assert flask.g.remote_addr == \"192.168.0.22\"\n        assert flask.g.user_agent == \"Foo\"\n\n\ndef test_client_open_environ(app, client, request):\n    @app.route(\"/index\")\n    def index():\n        return flask.request.remote_addr\n\n    builder = EnvironBuilder(app, path=\"/index\", method=\"GET\")\n    request.addfinalizer(builder.close)\n\n    rv = client.open(builder)\n    assert rv.data == b\"127.0.0.1\"\n\n    environ = builder.get_environ()\n    client.environ_base[\"REMOTE_ADDR\"] = \"127.0.0.2\"\n    rv = client.open(environ)\n    assert rv.data == b\"127.0.0.2\"\n\n\ndef test_specify_url_scheme(app, client):\n    @app.route(\"/\")\n    def index():\n        return flask.request.url\n\n    ctx = app.test_request_context(url_scheme=\"https\")\n    assert ctx.request.url == \"https://localhost/\"\n\n    rv = client.get(\"/\", url_scheme=\"https\")\n    assert rv.data == b\"https://localhost/\"\n\n\ndef test_path_is_url(app):\n    eb = EnvironBuilder(app, \"https://example.com/\")\n    assert eb.url_scheme == \"https\"\n    assert eb.host == \"example.com\"\n    assert eb.script_root == \"\"\n    assert eb.path == \"/\"\n\n\ndef test_environbuilder_json_dumps(app):\n    \"\"\"EnvironBuilder.json_dumps() takes settings from the app.\"\"\"\n    app.json.ensure_ascii = False\n    eb = EnvironBuilder(app, json=\"\\u20ac\")\n    assert eb.input_stream.read().decode(\"utf8\") == '\"\\u20ac\"'\n\n\ndef test_blueprint_with_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"example.com:1234\"\n    app.config[\"APPLICATION_ROOT\"] = \"/foo\"\n    client = app.test_client()\n\n    bp = flask.Blueprint(\"company\", __name__, subdomain=\"xxx\")\n\n    @bp.route(\"/\")\n    def index():\n        return flask.request.url\n\n    app.register_blueprint(bp)\n\n    ctx = app.test_request_context(\"/\", subdomain=\"xxx\")\n    assert ctx.request.url == \"http://xxx.example.com:1234/foo/\"\n\n    with ctx:\n        assert ctx.request.blueprint == bp.name\n\n    rv = client.get(\"/\", subdomain=\"xxx\")\n    assert rv.data == b\"http://xxx.example.com:1234/foo/\"\n\n\ndef test_redirect_session(app, client, app_ctx):\n    @app.route(\"/redirect\")\n    def index():\n        flask.session[\"redirect\"] = True\n        return flask.redirect(\"/target\")\n\n    @app.route(\"/target\")\n    def get_session():\n        flask.session[\"target\"] = True\n        return \"\"\n\n    with client:\n        client.get(\"/redirect\", follow_redirects=True)\n        assert flask.session[\"redirect\"] is True\n        assert flask.session[\"target\"] is True\n\n\ndef test_session_transactions(app, client):\n    @app.route(\"/\")\n    def index():\n        return str(flask.session[\"foo\"])\n\n    with client:\n        with client.session_transaction() as sess:\n            assert len(sess) == 0\n            sess[\"foo\"] = [42]\n            assert len(sess) == 1\n        rv = client.get(\"/\")\n        assert rv.data == b\"[42]\"\n        with client.session_transaction() as sess:\n            assert len(sess) == 1\n            assert sess[\"foo\"] == [42]\n\n\ndef test_session_transactions_no_null_sessions():\n    app = flask.Flask(__name__)\n\n    with app.test_client() as c:\n        with pytest.raises(RuntimeError) as e:\n            with c.session_transaction():\n                pass\n        assert \"Session backend did not open a session\" in str(e.value)\n\n\ndef test_session_transactions_keep_context(app, client, req_ctx):\n    client.get(\"/\")\n    req = flask.request._get_current_object()\n    assert req is not None\n    with client.session_transaction():\n        assert req is flask.request._get_current_object()\n\n\ndef test_session_transaction_needs_cookies(app):\n    c = app.test_client(use_cookies=False)\n\n    with pytest.raises(TypeError, match=\"Cookies are disabled.\"):\n        with c.session_transaction():\n            pass\n\n\ndef test_test_client_context_binding(app, client):\n    app.testing = False\n\n    @app.route(\"/\")\n    def index():\n        flask.g.value = 42\n        return \"Hello World!\"\n\n    @app.route(\"/other\")\n    def other():\n        raise ZeroDivisionError\n\n    with client:\n        resp = client.get(\"/\")\n        assert flask.g.value == 42\n        assert resp.data == b\"Hello World!\"\n        assert resp.status_code == 200\n\n    with client:\n        resp = client.get(\"/other\")\n        assert not hasattr(flask.g, \"value\")\n        assert b\"Internal Server Error\" in resp.data\n        assert resp.status_code == 500\n        flask.g.value = 23\n\n    with pytest.raises(RuntimeError):\n        flask.g.value  # noqa: B018\n\n\ndef test_reuse_client(client):\n    c = client\n\n    with c:\n        assert client.get(\"/\").status_code == 404\n\n    with c:\n        assert client.get(\"/\").status_code == 404\n\n\ndef test_full_url_request(app, client):\n    @app.route(\"/action\", methods=[\"POST\"])\n    def action():\n        return \"x\"\n\n    with client:\n        rv = client.post(\"http://domain.com/action?vodka=42\", data={\"gin\": 43})\n        assert rv.status_code == 200\n        assert \"gin\" in flask.request.form\n        assert \"vodka\" in flask.request.args\n\n\ndef test_json_request_and_response(app, client):\n    @app.route(\"/echo\", methods=[\"POST\"])\n    def echo():\n        return jsonify(flask.request.get_json())\n\n    with client:\n        json_data = {\"drink\": {\"gin\": 1, \"tonic\": True}, \"price\": 10}\n        rv = client.post(\"/echo\", json=json_data)\n\n        # Request should be in JSON\n        assert flask.request.is_json\n        assert flask.request.get_json() == json_data\n\n        # Response should be in JSON\n        assert rv.status_code == 200\n        assert rv.is_json\n        assert rv.get_json() == json_data\n\n\ndef test_client_json_no_app_context(app, client):\n    @app.route(\"/hello\", methods=[\"POST\"])\n    def hello():\n        return f\"Hello, {flask.request.json['name']}!\"\n\n    class Namespace:\n        count = 0\n\n        def add(self, app):\n            self.count += 1\n\n    ns = Namespace()\n\n    with appcontext_popped.connected_to(ns.add, app):\n        rv = client.post(\"/hello\", json={\"name\": \"Flask\"})\n\n    assert rv.get_data(as_text=True) == \"Hello, Flask!\"\n    assert ns.count == 1\n\n\ndef test_subdomain():\n    app = flask.Flask(__name__, subdomain_matching=True)\n    app.config[\"SERVER_NAME\"] = \"example.com\"\n    client = app.test_client()\n\n    @app.route(\"/\", subdomain=\"<company_id>\")\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for(\"view\", company_id=\"xxx\")\n\n    with client:\n        response = client.get(url)\n\n    assert 200 == response.status_code\n    assert b\"xxx\" == response.data\n\n\ndef test_nosubdomain(app, client):\n    app.config[\"SERVER_NAME\"] = \"example.com\"\n\n    @app.route(\"/<company_id>\")\n    def view(company_id):\n        return company_id\n\n    with app.test_request_context():\n        url = flask.url_for(\"view\", company_id=\"xxx\")\n\n    with client:\n        response = client.get(url)\n\n    assert 200 == response.status_code\n    assert b\"xxx\" == response.data\n\n\ndef test_cli_runner_class(app):\n    runner = app.test_cli_runner()\n    assert isinstance(runner, FlaskCliRunner)\n\n    class SubRunner(FlaskCliRunner):\n        pass\n\n    app.test_cli_runner_class = SubRunner\n    runner = app.test_cli_runner()\n    assert isinstance(runner, SubRunner)\n\n\ndef test_cli_invoke(app):\n    @app.cli.command(\"hello\")\n    def hello_command():\n        click.echo(\"Hello, World!\")\n\n    runner = app.test_cli_runner()\n    # invoke with command name\n    result = runner.invoke(args=[\"hello\"])\n    assert \"Hello\" in result.output\n    # invoke with command object\n    result = runner.invoke(hello_command)\n    assert \"Hello\" in result.output\n\n\ndef test_cli_custom_obj(app):\n    class NS:\n        called = False\n\n    def create_app():\n        NS.called = True\n        return app\n\n    @app.cli.command(\"hello\")\n    def hello_command():\n        click.echo(\"Hello, World!\")\n\n    script_info = ScriptInfo(create_app=create_app)\n    runner = app.test_cli_runner()\n    runner.invoke(hello_command, obj=script_info)\n    assert NS.called\n\n\ndef test_client_pop_all_preserved(app, req_ctx, client):\n    @app.route(\"/\")\n    def index():\n        # stream_with_context pushes a third context, preserved by response\n        return flask.stream_with_context(\"hello\")\n\n    # req_ctx fixture pushed an initial context\n    with client:\n        # request pushes a second request context, preserved by client\n        rv = client.get(\"/\")\n\n    # close the response, releasing the context held by stream_with_context\n    rv.close()\n    # only req_ctx fixture should still be pushed\n    assert _cv_request.get(None) is req_ctx\n"
    }
  },
  {
    "id": "pr-5723",
    "description": "Update macOS UI reference to \u201cSystem Settings\u201d\n\nmade changes to rename system preferences to system settings according to new mac os name change\r\n\r\nDocs: Update macOS UI reference to \u201cSystem Settings\u201d\r\n\r\nThis PR updates the documentation in docs/server.rst to reflect the latest macOS UI terminology.\r\nSpecifically, it replaces the outdated term \u201cSystem Preferences\u201d with \u201cSystem Settings\u201d, aligning with macOS Ventura and later versions.\r\n\r\nWhat Changed\r\n\u2022 Line updated in instructions to disable AirPlay Receiver from:\r\n\u2022 \"System Preferences\" \u2192 \"System Settings\"\r\n\r\nNotes\r\n\u2022 No issue was created for this change, as it is a minor documentation correction.\r\n\u2022 This update does not affect any code or behavior.\r\n\u2022 No test or changelog entry required per contribution guidelines for doc typo-level fixes.",
    "has_bug": false,
    "base_commit": "a42c4d54a3e5cd56c0700479ede75157a748acd6",
    "pr_url": "https://github.com/pallets/flask/pull/5723",
    "merged_at": "2025-08-18T17:08:08Z",
    "expected_files": [
      "docs/server.rst"
    ],
    "oracle_tests": {}
  },
  {
    "id": "pr-5742",
    "description": "Docs: Fix escaping in HTML escaping example\n\nThe code in the [Quickstart's HTML Escaping section](https://flask.palletsprojects.com/en/stable/quickstart/#html-escaping) does not render `name=<script>alert(\"bad\")</script>` to text because the slash in </script> gets interpreted as a trailing slash, leading to a 404.\r\n\r\nGetting the name as a query parameter instead allows:\r\n1. the script tag to be rendered as text if HTML escaping is done\r\n2. the alert in the script tag to be executed if HTML escaping is not done.",
    "has_bug": true,
    "base_commit": "7fea7cf15688b2a2712b01c45c9e3385ea382e67",
    "pr_url": "https://github.com/pallets/flask/pull/5742",
    "merged_at": "2025-08-18T17:20:07Z",
    "expected_files": [
      "docs/quickstart.rst"
    ],
    "oracle_tests": {}
  },
  {
    "id": "pr-5777",
    "description": "use IO[bytes] instead of BinaryIO for wider compatibility\n\n`flask.helpers.send_file` was the only place where `t.BinaryIO` was used. I changed it to be more loose type `t.IO[bytes]`.\r\n\r\nfixes #5776 \r\n",
    "has_bug": false,
    "base_commit": "c56c5ec7c41e6ffd02516bf7cb80dd2ba9ba7aa3",
    "pr_url": "https://github.com/pallets/flask/pull/5777",
    "merged_at": "2025-08-18T17:26:12Z",
    "expected_files": [
      "CHANGES.rst",
      "src/flask/helpers.py"
    ],
    "oracle_tests": {}
  },
  {
    "id": "pr-5798",
    "description": "security docs for TRUSTED_HOSTS\n\ncloses #5718",
    "has_bug": false,
    "base_commit": "ff64079a516c269f171ababf3d92b86886a62ffd",
    "pr_url": "https://github.com/pallets/flask/pull/5798",
    "merged_at": "2025-08-18T18:44:57Z",
    "expected_files": [
      "docs/web-security.rst"
    ],
    "oracle_tests": {}
  },
  {
    "id": "pr-5757",
    "description": "svg logo\n\nUse SVG instead of PNG for the logo.",
    "has_bug": false,
    "base_commit": "f04c5e696400badaa52b3450ded53e9091c2078a",
    "pr_url": "https://github.com/pallets/flask/pull/5757",
    "merged_at": "2025-06-09T21:33:26Z",
    "expected_files": [
      "README.md",
      "docs/_static/flask-horizontal.png",
      "docs/_static/flask-horizontal.svg",
      "docs/_static/flask-icon.svg",
      "docs/_static/flask-vertical.png",
      "docs/_static/flask-vertical.svg",
      "docs/_static/shortcut-icon.png",
      "docs/conf.py",
      "docs/index.rst"
    ],
    "oracle_tests": {}
  },
  {
    "id": "pr-5754",
    "description": "remove slsa provenance\n\nPyPI and trusted publishing has built-in attestation support now.",
    "has_bug": false,
    "base_commit": "a42c4d54a3e5cd56c0700479ede75157a748acd6",
    "pr_url": "https://github.com/pallets/flask/pull/5754",
    "merged_at": "2025-06-08T16:47:45Z",
    "expected_files": [
      ".github/workflows/publish.yaml",
      "pyproject.toml"
    ],
    "oracle_tests": {}
  },
  {
    "id": "pr-5737",
    "description": "Fix global CONTRIBUTING link\n\nFixes the live contributing guidelines link, which just links to https://flask.palletsprojects.com/en/stable/contributing/_contrib (i.e. it puts the RST slug in the URL somehow).\r\n\r\nI wrapped to 80 characters, let me know if that's incorrect.",
    "has_bug": true,
    "base_commit": "bbaf13333fd00644313488243cfe547b13dcae78",
    "pr_url": "https://github.com/pallets/flask/pull/5737",
    "merged_at": "2025-05-20T16:30:06Z",
    "expected_files": [
      "docs/contributing.rst"
    ],
    "oracle_tests": {}
  },
  {
    "id": "pr-5731",
    "description": "drop end of life python versions\n\nhttps://palletsprojects.com/versions\r\n\r\n> When a release is made, it supports all Python versions that are not within six months of end of life (EOL). See [Python's EOL calendar](https://devguide.python.org/versions/) for timing.",
    "has_bug": false,
    "base_commit": "e7e53807766ef1470bce546716a675ded4b08597",
    "pr_url": "https://github.com/pallets/flask/pull/5731",
    "merged_at": "2025-05-13T15:35:41Z",
    "expected_files": [
      ".github/workflows/tests.yaml",
      "CHANGES.rst",
      "docs/extensiondev.rst",
      "docs/installation.rst",
      "pyproject.toml",
      "src/flask/cli.py",
      "src/flask/json/provider.py",
      "src/flask/sansio/app.py",
      "src/flask/typing.py",
      "tests/test_cli.py",
      "uv.lock"
    ],
    "oracle_tests": {
      ".github/workflows/tests.yaml": "name: Tests\non:\n  pull_request:\n    paths-ignore: ['docs/**', 'README.md']\n  push:\n    branches: [main, stable]\n    paths-ignore: ['docs/**', 'README.md']\njobs:\n  tests:\n    name: ${{ matrix.name || matrix.python }}\n    runs-on: ${{ matrix.os || 'ubuntu-latest' }}\n    strategy:\n      fail-fast: false\n      matrix:\n        include:\n          - {python: '3.13'}\n          - {name: Windows, python: '3.13', os: windows-latest}\n          - {name: Mac, python: '3.13', os: macos-latest}\n          - {python: '3.12'}\n          - {python: '3.11'}\n          - {python: '3.10'}\n          - {name: PyPy, python: 'pypy-3.11', tox: pypy3.11}\n          - {name: Minimum Versions, python: '3.13', tox: tests-min}\n          - {name: Development Versions, python: '3.10', tox: tests-dev}\n    steps:\n      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n      - uses: astral-sh/setup-uv@6b9c6063abd6010835644d4c2e1bef4cf5cd0fca # v6.0.1\n        with:\n          enable-cache: true\n          prune-cache: false\n      - uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0\n        with:\n          python-version: ${{ matrix.python }}\n      - run: uv run --locked tox run -e ${{ matrix.tox || format('py{0}', matrix.python) }}\n  typing:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2\n      - uses: astral-sh/setup-uv@6b9c6063abd6010835644d4c2e1bef4cf5cd0fca # v6.0.1\n        with:\n          enable-cache: true\n          prune-cache: false\n      - uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0\n        with:\n          python-version-file: pyproject.toml\n      - name: cache mypy\n        uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 # v4.2.3\n        with:\n          path: ./.mypy_cache\n          key: mypy|${{ hashFiles('pyproject.toml') }}\n      - run: uv run --locked tox run -e typing\n",
      "tests/test_cli.py": "# This file was part of Flask-CLI and was modified under the terms of\n# its Revised BSD License. Copyright \u00a9 2015 CERN.\nimport importlib.metadata\nimport os\nimport platform\nimport ssl\nimport sys\nimport types\nfrom functools import partial\nfrom pathlib import Path\n\nimport click\nimport pytest\nfrom _pytest.monkeypatch import notset\nfrom click.testing import CliRunner\n\nfrom flask import Blueprint\nfrom flask import current_app\nfrom flask import Flask\nfrom flask.cli import AppGroup\nfrom flask.cli import find_best_app\nfrom flask.cli import FlaskGroup\nfrom flask.cli import get_version\nfrom flask.cli import load_dotenv\nfrom flask.cli import locate_app\nfrom flask.cli import NoAppException\nfrom flask.cli import prepare_import\nfrom flask.cli import run_command\nfrom flask.cli import ScriptInfo\nfrom flask.cli import with_appcontext\n\ncwd = Path.cwd()\ntest_path = (Path(__file__) / \"..\" / \"test_apps\").resolve()\n\n\n@pytest.fixture\ndef runner():\n    return CliRunner()\n\n\ndef test_cli_name(test_apps):\n    \"\"\"Make sure the CLI object's name is the app's name and not the app itself\"\"\"\n    from cliapp.app import testapp\n\n    assert testapp.cli.name == testapp.name\n\n\ndef test_find_best_app(test_apps):\n    class Module:\n        app = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.app\n\n    class Module:\n        application = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.application\n\n    class Module:\n        myapp = Flask(\"appname\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        @staticmethod\n        def create_app():\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        @staticmethod\n        def create_app(**kwargs):\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        @staticmethod\n        def make_app():\n            return Flask(\"appname\")\n\n    app = find_best_app(Module)\n    assert isinstance(app, Flask)\n    assert app.name == \"appname\"\n\n    class Module:\n        myapp = Flask(\"appname1\")\n\n        @staticmethod\n        def create_app():\n            return Flask(\"appname2\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        myapp = Flask(\"appname1\")\n\n        @staticmethod\n        def create_app():\n            return Flask(\"appname2\")\n\n    assert find_best_app(Module) == Module.myapp\n\n    class Module:\n        pass\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        myapp1 = Flask(\"appname1\")\n        myapp2 = Flask(\"appname2\")\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        @staticmethod\n        def create_app(foo, bar):\n            return Flask(\"appname2\")\n\n    pytest.raises(NoAppException, find_best_app, Module)\n\n    class Module:\n        @staticmethod\n        def create_app():\n            raise TypeError(\"bad bad factory!\")\n\n    pytest.raises(TypeError, find_best_app, Module)\n\n\n@pytest.mark.parametrize(\n    \"value,path,result\",\n    (\n        (\"test\", cwd, \"test\"),\n        (\"test.py\", cwd, \"test\"),\n        (\"a/test\", cwd / \"a\", \"test\"),\n        (\"test/__init__.py\", cwd, \"test\"),\n        (\"test/__init__\", cwd, \"test\"),\n        # nested package\n        (\n            test_path / \"cliapp\" / \"inner1\" / \"__init__\",\n            test_path,\n            \"cliapp.inner1\",\n        ),\n        (\n            test_path / \"cliapp\" / \"inner1\" / \"inner2\",\n            test_path,\n            \"cliapp.inner1.inner2\",\n        ),\n        # dotted name\n        (\"test.a.b\", cwd, \"test.a.b\"),\n        (test_path / \"cliapp.app\", test_path, \"cliapp.app\"),\n        # not a Python file, will be caught during import\n        (test_path / \"cliapp\" / \"message.txt\", test_path, \"cliapp.message.txt\"),\n    ),\n)\ndef test_prepare_import(request, value, path, result):\n    \"\"\"Expect the correct path to be set and the correct import and app names\n    to be returned.\n\n    :func:`prepare_exec_for_file` has a side effect where the parent directory\n    of the given import is added to :data:`sys.path`. This is reset after the\n    test runs.\n    \"\"\"\n    original_path = sys.path[:]\n\n    def reset_path():\n        sys.path[:] = original_path\n\n    request.addfinalizer(reset_path)\n\n    assert prepare_import(value) == result\n    assert sys.path[0] == str(path)\n\n\n@pytest.mark.parametrize(\n    \"iname,aname,result\",\n    (\n        (\"cliapp.app\", None, \"testapp\"),\n        (\"cliapp.app\", \"testapp\", \"testapp\"),\n        (\"cliapp.factory\", None, \"app\"),\n        (\"cliapp.factory\", \"create_app\", \"app\"),\n        (\"cliapp.factory\", \"create_app()\", \"app\"),\n        (\"cliapp.factory\", 'create_app2(\"foo\", \"bar\")', \"app2_foo_bar\"),\n        # trailing comma space\n        (\"cliapp.factory\", 'create_app2(\"foo\", \"bar\", )', \"app2_foo_bar\"),\n        # strip whitespace\n        (\"cliapp.factory\", \" create_app () \", \"app\"),\n    ),\n)\ndef test_locate_app(test_apps, iname, aname, result):\n    assert locate_app(iname, aname).name == result\n\n\n@pytest.mark.parametrize(\n    \"iname,aname\",\n    (\n        (\"notanapp.py\", None),\n        (\"cliapp/app\", None),\n        (\"cliapp.app\", \"notanapp\"),\n        # not enough arguments\n        (\"cliapp.factory\", 'create_app2(\"foo\")'),\n        # invalid identifier\n        (\"cliapp.factory\", \"create_app(\"),\n        # no app returned\n        (\"cliapp.factory\", \"no_app\"),\n        # nested import error\n        (\"cliapp.importerrorapp\", None),\n        # not a Python file\n        (\"cliapp.message.txt\", None),\n    ),\n)\ndef test_locate_app_raises(test_apps, iname, aname):\n    with pytest.raises(NoAppException):\n        locate_app(iname, aname)\n\n\ndef test_locate_app_suppress_raise(test_apps):\n    app = locate_app(\"notanapp.py\", None, raise_if_not_found=False)\n    assert app is None\n\n    # only direct import error is suppressed\n    with pytest.raises(NoAppException):\n        locate_app(\"cliapp.importerrorapp\", None, raise_if_not_found=False)\n\n\ndef test_get_version(test_apps, capsys):\n    class MockCtx:\n        resilient_parsing = False\n        color = None\n\n        def exit(self):\n            return\n\n    ctx = MockCtx()\n    get_version(ctx, None, \"test\")\n    out, err = capsys.readouterr()\n    assert f\"Python {platform.python_version()}\" in out\n    assert f\"Flask {importlib.metadata.version('flask')}\" in out\n    assert f\"Werkzeug {importlib.metadata.version('werkzeug')}\" in out\n\n\ndef test_scriptinfo(test_apps, monkeypatch):\n    obj = ScriptInfo(app_import_path=\"cliapp.app:testapp\")\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n\n    # import app with module's absolute path\n    cli_app_path = str(test_path / \"cliapp\" / \"app.py\")\n\n    obj = ScriptInfo(app_import_path=cli_app_path)\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n    obj = ScriptInfo(app_import_path=f\"{cli_app_path}:testapp\")\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n    assert obj.load_app() is app\n\n    def create_app():\n        return Flask(\"createapp\")\n\n    obj = ScriptInfo(create_app=create_app)\n    app = obj.load_app()\n    assert app.name == \"createapp\"\n    assert obj.load_app() is app\n\n    obj = ScriptInfo()\n    pytest.raises(NoAppException, obj.load_app)\n\n    # import app from wsgi.py in current directory\n    monkeypatch.chdir(test_path / \"helloworld\")\n    obj = ScriptInfo()\n    app = obj.load_app()\n    assert app.name == \"hello\"\n\n    # import app from app.py in current directory\n    monkeypatch.chdir(test_path / \"cliapp\")\n    obj = ScriptInfo()\n    app = obj.load_app()\n    assert app.name == \"testapp\"\n\n\ndef test_app_cli_has_app_context(app, runner):\n    def _param_cb(ctx, param, value):\n        # current_app should be available in parameter callbacks\n        return bool(current_app)\n\n    @app.cli.command()\n    @click.argument(\"value\", callback=_param_cb)\n    def check(value):\n        app = click.get_current_context().obj.load_app()\n        # the loaded app should be the same as current_app\n        same_app = current_app._get_current_object() is app\n        return same_app, value\n\n    cli = FlaskGroup(create_app=lambda: app)\n    result = runner.invoke(cli, [\"check\", \"x\"], standalone_mode=False)\n    assert result.return_value == (True, True)\n\n\ndef test_with_appcontext(runner):\n    @click.command()\n    @with_appcontext\n    def testcmd():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda: Flask(\"testapp\"))\n\n    result = runner.invoke(testcmd, obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testapp\\n\"\n\n\ndef test_appgroup_app_context(runner):\n    @click.group(cls=AppGroup)\n    def cli():\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    @cli.group()\n    def subgroup():\n        pass\n\n    @subgroup.command()\n    def test2():\n        click.echo(current_app.name)\n\n    obj = ScriptInfo(create_app=lambda: Flask(\"testappgroup\"))\n\n    result = runner.invoke(cli, [\"test\"], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testappgroup\\n\"\n\n    result = runner.invoke(cli, [\"subgroup\", \"test2\"], obj=obj)\n    assert result.exit_code == 0\n    assert result.output == \"testappgroup\\n\"\n\n\ndef test_flaskgroup_app_context(runner):\n    def create_app():\n        return Flask(\"flaskgroup\")\n\n    @click.group(cls=FlaskGroup, create_app=create_app)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, [\"test\"])\n    assert result.exit_code == 0\n    assert result.output == \"flaskgroup\\n\"\n\n\n@pytest.mark.parametrize(\"set_debug_flag\", (True, False))\ndef test_flaskgroup_debug(runner, set_debug_flag):\n    def create_app():\n        app = Flask(\"flaskgroup\")\n        app.debug = True\n        return app\n\n    @click.group(cls=FlaskGroup, create_app=create_app, set_debug_flag=set_debug_flag)\n    def cli(**params):\n        pass\n\n    @cli.command()\n    def test():\n        click.echo(str(current_app.debug))\n\n    result = runner.invoke(cli, [\"test\"])\n    assert result.exit_code == 0\n    assert result.output == f\"{not set_debug_flag}\\n\"\n\n\ndef test_flaskgroup_nested(app, runner):\n    cli = click.Group(\"cli\")\n    flask_group = FlaskGroup(name=\"flask\", create_app=lambda: app)\n    cli.add_command(flask_group)\n\n    @flask_group.command()\n    def show():\n        click.echo(current_app.name)\n\n    result = runner.invoke(cli, [\"flask\", \"show\"])\n    assert result.output == \"flask_test\\n\"\n\n\ndef test_no_command_echo_loading_error():\n    from flask.cli import cli\n\n    try:\n        runner = CliRunner(mix_stderr=False)\n    except (DeprecationWarning, TypeError):\n        # Click >= 8.2\n        runner = CliRunner()\n\n    result = runner.invoke(cli, [\"missing\"])\n    assert result.exit_code == 2\n    assert \"FLASK_APP\" in result.stderr\n    assert \"Usage:\" in result.stderr\n\n\ndef test_help_echo_loading_error():\n    from flask.cli import cli\n\n    try:\n        runner = CliRunner(mix_stderr=False)\n    except (DeprecationWarning, TypeError):\n        # Click >= 8.2\n        runner = CliRunner()\n\n    result = runner.invoke(cli, [\"--help\"])\n    assert result.exit_code == 0\n    assert \"FLASK_APP\" in result.stderr\n    assert \"Usage:\" in result.stdout\n\n\ndef test_help_echo_exception():\n    def create_app():\n        raise Exception(\"oh no\")\n\n    cli = FlaskGroup(create_app=create_app)\n\n    try:\n        runner = CliRunner(mix_stderr=False)\n    except (DeprecationWarning, TypeError):\n        # Click >= 8.2\n        runner = CliRunner()\n\n    result = runner.invoke(cli, [\"--help\"])\n    assert result.exit_code == 0\n    assert \"Exception: oh no\" in result.stderr\n    assert \"Usage:\" in result.stdout\n\n\nclass TestRoutes:\n    @pytest.fixture\n    def app(self):\n        app = Flask(__name__)\n        app.add_url_rule(\n            \"/get_post/<int:x>/<int:y>\",\n            methods=[\"GET\", \"POST\"],\n            endpoint=\"yyy_get_post\",\n        )\n        app.add_url_rule(\"/zzz_post\", methods=[\"POST\"], endpoint=\"aaa_post\")\n        return app\n\n    @pytest.fixture\n    def invoke(self, app, runner):\n        cli = FlaskGroup(create_app=lambda: app)\n        return partial(runner.invoke, cli)\n\n    def expect_order(self, order, output):\n        # skip the header and match the start of each row\n        for expect, line in zip(order, output.splitlines()[2:], strict=False):\n            # do this instead of startswith for nicer pytest output\n            assert line[: len(expect)] == expect\n\n    def test_simple(self, invoke):\n        result = invoke([\"routes\"])\n        assert result.exit_code == 0\n        self.expect_order([\"aaa_post\", \"static\", \"yyy_get_post\"], result.output)\n\n    def test_sort(self, app, invoke):\n        default_output = invoke([\"routes\"]).output\n        endpoint_output = invoke([\"routes\", \"-s\", \"endpoint\"]).output\n        assert default_output == endpoint_output\n        self.expect_order(\n            [\"static\", \"yyy_get_post\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"methods\"]).output,\n        )\n        self.expect_order(\n            [\"yyy_get_post\", \"static\", \"aaa_post\"],\n            invoke([\"routes\", \"-s\", \"rule\"]).output,\n        )\n        match_order = [r.endpoint for r in app.url_map.iter_rules()]\n        self.expect_order(match_order, invoke([\"routes\", \"-s\", \"match\"]).output)\n\n    def test_all_methods(self, invoke):\n        output = invoke([\"routes\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" not in output\n        output = invoke([\"routes\", \"--all-methods\"]).output\n        assert \"GET, HEAD, OPTIONS, POST\" in output\n\n    def test_no_routes(self, runner):\n        app = Flask(__name__, static_folder=None)\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"No routes were registered.\" in result.output\n\n    def test_subdomain(self, runner):\n        app = Flask(__name__, static_folder=None)\n        app.add_url_rule(\"/a\", subdomain=\"a\", endpoint=\"a\")\n        app.add_url_rule(\"/b\", subdomain=\"b\", endpoint=\"b\")\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"Subdomain\" in result.output\n\n    def test_host(self, runner):\n        app = Flask(__name__, static_folder=None, host_matching=True)\n        app.add_url_rule(\"/a\", host=\"a\", endpoint=\"a\")\n        app.add_url_rule(\"/b\", host=\"b\", endpoint=\"b\")\n        cli = FlaskGroup(create_app=lambda: app)\n        result = runner.invoke(cli, [\"routes\"])\n        assert result.exit_code == 0\n        assert \"Host\" in result.output\n\n\ndef dotenv_not_available():\n    try:\n        import dotenv  # noqa: F401\n    except ImportError:\n        return True\n\n    return False\n\n\nneed_dotenv = pytest.mark.skipif(\n    dotenv_not_available(), reason=\"dotenv is not installed\"\n)\n\n\n@need_dotenv\ndef test_load_dotenv(monkeypatch):\n    # can't use monkeypatch.delitem since the keys don't exist yet\n    for item in (\"FOO\", \"BAR\", \"SPAM\", \"HAM\"):\n        monkeypatch._setitem.append((os.environ, item, notset))\n\n    monkeypatch.setenv(\"EGGS\", \"3\")\n    monkeypatch.chdir(test_path)\n    assert load_dotenv()\n    assert Path.cwd() == test_path\n    # .flaskenv doesn't overwrite .env\n    assert os.environ[\"FOO\"] == \"env\"\n    # set only in .flaskenv\n    assert os.environ[\"BAR\"] == \"bar\"\n    # set only in .env\n    assert os.environ[\"SPAM\"] == \"1\"\n    # set manually, files don't overwrite\n    assert os.environ[\"EGGS\"] == \"3\"\n    # test env file encoding\n    assert os.environ[\"HAM\"] == \"\u706b\u817f\"\n    # Non existent file should not load\n    assert not load_dotenv(\"non-existent-file\", load_defaults=False)\n\n\n@need_dotenv\ndef test_dotenv_path(monkeypatch):\n    for item in (\"FOO\", \"BAR\", \"EGGS\"):\n        monkeypatch._setitem.append((os.environ, item, notset))\n\n    load_dotenv(test_path / \".flaskenv\")\n    assert Path.cwd() == cwd\n    assert \"FOO\" in os.environ\n\n\ndef test_dotenv_optional(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"dotenv\", None)\n    monkeypatch.chdir(test_path)\n    load_dotenv()\n    assert \"FOO\" not in os.environ\n\n\n@need_dotenv\ndef test_disable_dotenv_from_env(monkeypatch, runner):\n    monkeypatch.chdir(test_path)\n    monkeypatch.setitem(os.environ, \"FLASK_SKIP_DOTENV\", \"1\")\n    runner.invoke(FlaskGroup())\n    assert \"FOO\" not in os.environ\n\n\ndef test_run_cert_path():\n    # no key\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", __file__])\n\n    # no cert\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--key\", __file__])\n\n    # cert specified first\n    ctx = run_command.make_context(\"run\", [\"--cert\", __file__, \"--key\", __file__])\n    assert ctx.params[\"cert\"] == (__file__, __file__)\n\n    # key specified first\n    ctx = run_command.make_context(\"run\", [\"--key\", __file__, \"--cert\", __file__])\n    assert ctx.params[\"cert\"] == (__file__, __file__)\n\n\ndef test_run_cert_adhoc(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"cryptography\", None)\n\n    # cryptography not installed\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"adhoc\"])\n\n    # cryptography installed\n    monkeypatch.setitem(sys.modules, \"cryptography\", types.ModuleType(\"cryptography\"))\n    ctx = run_command.make_context(\"run\", [\"--cert\", \"adhoc\"])\n    assert ctx.params[\"cert\"] == \"adhoc\"\n\n    # no key with adhoc\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"adhoc\", \"--key\", __file__])\n\n\ndef test_run_cert_import(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"not_here\", None)\n\n    # ImportError\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"not_here\"])\n\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"flask\"])\n\n    # SSLContext\n    ssl_context = ssl.SSLContext(ssl.PROTOCOL_TLS_SERVER)\n\n    monkeypatch.setitem(sys.modules, \"ssl_context\", ssl_context)\n    ctx = run_command.make_context(\"run\", [\"--cert\", \"ssl_context\"])\n    assert ctx.params[\"cert\"] is ssl_context\n\n    # no --key with SSLContext\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"ssl_context\", \"--key\", __file__])\n\n\ndef test_run_cert_no_ssl(monkeypatch):\n    monkeypatch.setitem(sys.modules, \"ssl\", None)\n\n    with pytest.raises(click.BadParameter):\n        run_command.make_context(\"run\", [\"--cert\", \"not_here\"])\n\n\ndef test_cli_blueprints(app):\n    \"\"\"Test blueprint commands register correctly to the application\"\"\"\n    custom = Blueprint(\"custom\", __name__, cli_group=\"customized\")\n    nested = Blueprint(\"nested\", __name__)\n    merged = Blueprint(\"merged\", __name__, cli_group=None)\n    late = Blueprint(\"late\", __name__)\n\n    @custom.cli.command(\"custom\")\n    def custom_command():\n        click.echo(\"custom_result\")\n\n    @nested.cli.command(\"nested\")\n    def nested_command():\n        click.echo(\"nested_result\")\n\n    @merged.cli.command(\"merged\")\n    def merged_command():\n        click.echo(\"merged_result\")\n\n    @late.cli.command(\"late\")\n    def late_command():\n        click.echo(\"late_result\")\n\n    app.register_blueprint(custom)\n    app.register_blueprint(nested)\n    app.register_blueprint(merged)\n    app.register_blueprint(late, cli_group=\"late_registration\")\n\n    app_runner = app.test_cli_runner()\n\n    result = app_runner.invoke(args=[\"customized\", \"custom\"])\n    assert \"custom_result\" in result.output\n\n    result = app_runner.invoke(args=[\"nested\", \"nested\"])\n    assert \"nested_result\" in result.output\n\n    result = app_runner.invoke(args=[\"merged\"])\n    assert \"merged_result\" in result.output\n\n    result = app_runner.invoke(args=[\"late_registration\", \"late\"])\n    assert \"late_result\" in result.output\n\n\ndef test_cli_empty(app):\n    \"\"\"If a Blueprint's CLI group is empty, do not register it.\"\"\"\n    bp = Blueprint(\"blue\", __name__, cli_group=\"blue\")\n    app.register_blueprint(bp)\n\n    result = app.test_cli_runner().invoke(args=[\"blue\", \"--help\"])\n    assert result.exit_code == 2, f\"Unexpected success:\\n\\n{result.output}\"\n\n\ndef test_run_exclude_patterns():\n    ctx = run_command.make_context(\"run\", [\"--exclude-patterns\", __file__])\n    assert ctx.params[\"exclude_patterns\"] == [__file__]\n"
    }
  }
]