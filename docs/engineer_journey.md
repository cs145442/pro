# The Journey of a Great Software Engineer: From College to Principal

## Phase 1: College Student → New Grad

### Foundational Habits
- Wrote code every single day, even on weekends
- Didn't just complete assignments—extended them to explore "what if" scenarios
- Read textbooks cover-to-cover, not just exam chapters
- Built side projects that solved real problems they personally faced
- Contributed to open source before graduating (even small fixes)
- Learned to read other people's code (GitHub repos) as much as writing their own
- Documented everything they learned in personal notes/wikis
- Asked "why does this work?" not just "how do I make it work?"
- Learned at least one language deeply (not just syntax—memory model, concurrency, idioms)
- Failed interviews, analyzed what went wrong, and improved systematically
- Practiced algorithms not to pass interviews but to think computationally
- Built things from scratch first (database, web server, compiler) before using frameworks
- Understood that grades ≠ competence; built portfolio to prove skills

---

## Phase 2: Junior Engineer (0-2 years)

### Survival & Growth Habits
- Asked questions fearlessly but always showed they tried first
- Read the entire codebase before making changes (understood the "why" of existing code)
- Never copied code without understanding it
- Wrote tests before being told to
- Documented their own code even when no one asked
- Used version control properly from day one (meaningful commits, branches, PRs)
- Learned the debugging tools deeply (not just `print` statements)
- Took ownership of bugs they introduced—never blamed others
- Over-communicated status updates to manager and team
- Asked seniors for code reviews and actually incorporated feedback
- Kept a "brag doc" of accomplishments from week one
- Learned to estimate tasks and tracked actual vs. estimated time
- Volunteered for on-call and incident response to learn production systems
- Read postmortems obsessively to learn from others' failures
- Built relationships with senior engineers (not just technical skills)
- Learned the business domain, not just the code
- Understood that shipping > perfection
- Made mistakes, admitted them fast, learned faster

### Technical Foundations
- Mastered the IDE and keyboard shortcuts
- Learned to read logs, traces, and stack traces efficiently
- Understood basic system design (databases, caching, queues)
- Wrote clean, readable code over clever code
- Learned regular expressions, shell scripting, and command-line tools
- Understood networking basics (HTTP, DNS, TCP/IP)
- Could explain their code to non-technical people

---

## Phase 3: Intermediate Engineer (2-5 years)

### Deepening Expertise
- Owned features end-to-end (requirements → design → code → deploy → monitor)
- Learned to say "no" or "not yet" to scope creep
- Started mentoring juniors (teaching solidified their own knowledge)
- Wrote design docs before writing code
- Considered edge cases, failure modes, and rollback strategies before coding
- Learned to break large problems into smaller, shippable increments
- Built expertise in 1-2 specific areas (became the "go-to" person)
- Read papers and conference talks in their domain
- Started contributing to architecture discussions
- Learned to navigate ambiguity in requirements
- Understood technical debt and when to pay it down
- Learned to work with legacy code without complaining
- Could debug across multiple services/systems
- Started thinking about performance, scalability, and security proactively
- Learned to write for production (logging, metrics, alerting, graceful degradation)

### Soft Skills Development
- Gave clear, concise status updates in standups
- Wrote RFCs/design docs that others could understand
- Learned to disagree respectfully and commit
- Built trust by delivering consistently
- Started leading small projects (2-3 people)
- Learned to give constructive code review feedback
- Understood that code is read more than written—optimized for readability
- Developed empathy for users (attended support calls, read feedback)
- Learned to context-switch efficiently between tasks
- Built reputation by helping others succeed

---

## Phase 4: Senior Engineer (5-8 years)

### Technical Leadership
- Made architectural decisions that lasted years
- Wrote code that others wanted to copy (set patterns for the team)
- Anticipated problems before they happened
- Designed systems with failure in mind (what happens when X breaks?)
- Made trade-offs explicitly and documented them
- Knew when NOT to build something (buy vs. build vs. skip)
- Simplified complex systems (deletion > addition)
- Could estimate large projects accurately (broke them down scientifically)
- Reviewed code not just for correctness but for maintainability and design
- Wrote documentation that survived their departure
- Automated themselves out of repetitive tasks
- Built tools and libraries that made the whole team faster

### Scope & Influence
- Owned entire subsystems or products
- Could ramp up in a new codebase in days, not weeks
- Identified and fixed systemic problems (not just symptoms)
- Influenced technical direction without formal authority
- Built relationships across teams to unblock dependencies
- Started saying "we" instead of "I" for achievements
- Protected the team from unnecessary interruptions
- Could context-switch between IC work and mentoring seamlessly
- Knew when to dive deep vs. stay high-level
- Led incident response calmly under pressure

### Mindset Shifts
- Stopped measuring productivity by lines of code written
- Started measuring productivity by problems solved and team velocity
- Learned that being right ≠ winning (buy-in matters)
- Understood that 10x engineers make others 10x, not just themselves
- Stopped proving they were smart; started making the team look smart
- Embraced that legacy code was once someone's best effort
- Learned patience—big changes take time
- Accepted that not all problems are worth solving

---

## Phase 5: Staff/Lead Engineer (8-12 years)

### Strategic Impact
- Thought in quarters and years, not sprints
- Identified problems no one else saw yet
- Connected technical decisions to business outcomes
- Could explain complex systems to executives in 5 minutes
- Built technical roadmaps aligned with company strategy
- Made "boring" technology choices that scaled
- Knew the difference between "interesting" and "valuable" work
- Said "no" to more things than "yes" to preserve focus
- Delegated effectively while staying technically relevant
- Created self-sufficient teams that didn't need constant guidance

### Organizational Influence
- Mentored multiple seniors who became leads themselves
- Drove engineering culture and practices team-wide
- Wrote internal blog posts and gave tech talks
- Conducted architecture reviews across the organization
- Represented engineering in cross-functional planning
- Resolved conflicts between teams diplomatically
- Built bridges between engineering and product/design
- Championed developer experience internally
- Created processes that scaled (interviewing, onboarding, code review)

### Technical Judgment
- Knew when to optimize and when to leave it alone
- Could predict where systems would break in 2 years
- Made reversible decisions quickly, irreversible decisions slowly
- Understood the full stack yet knew their limits
- Could debug anything in production at 3am
- Read the source code of critical dependencies
- Maintained relationships with maintainers of key open source projects
- Stayed hands-on in code at least 30% of time

---

## Phase 6: Principal/Distinguished Engineer (12+ years)

### Company-Wide Impact
- Defined technical vision for the entire organization
- Made decisions that affected hundreds of engineers
- Killed projects that weren't working (hardest decisions)
- Built systems that outlasted their tenure by 5+ years
- Wrote the "golden" design docs that became templates
- Could debug any system in the company regardless of team
- Saved the company millions through architectural decisions
- Recognized when the company needed to change direction technically

### Industry Recognition
- Published papers, spoke at conferences, wrote books
- Open sourced impactful projects
- Built reputation that attracted talent to the company
- Maintained external network of industry peers
- Stayed humble despite recognition

### Meta-Skills
- Knew when to step back and let others lead
- Built systems that didn't need them
- Focused on leverage (one decision affecting 100 teams)
- Managed energy, not just time
- Continued learning despite decades of experience
- Changed their mind publicly when proven wrong
- Made the implicit explicit (documented tribal knowledge)
- Left every team better than they found it

---

## Practices Followed Throughout (The Constants)

### Daily Habits
- Read code every day (their own and others')
- Wrote something every day (code, docs, design)
- Reviewed at least one PR every day
- Learned something new every week
- Reflected on what went well and what didn't
- Kept notes on decisions and why they made them

### Weekly Habits
- 1:1s with manager (prepared agenda, asked for feedback)
- Met with peers across teams
- Reviewed their calendar and protected focus time
- Read industry news and newsletters
- Helped at least one person with a problem

### Monthly Habits
- Updated brag doc / accomplishments list
- Reviewed OKRs / goals progress
- Had skip-level meetings when possible
- Read at least one technical blog post/paper deeply
- Reviewed personal growth areas

### Continuous Practices
- **Read the fucking manual (RTFM)** before asking questions
- **Understood context** before proposing solutions
- **Under-promised and over-delivered**
- **Communicated proactively** (no one had to ask for updates)
- **Took notes** in every meeting
- **Followed up** on commitments within 24 hours
- **Tested in production** (with guardrails)
- **Monitored what they shipped**
- **Deleted code** as proudly as writing it
- **Automated what they did twice**
- **Asked "why" five times** before accepting requirements
- **Assumed positive intent** in others
- **Gave credit generously** and took blame personally
- **Built relationships** before needing them
- **Stayed curious** despite routine
- **Embraced boredom** (real work is often boring)
- **Protected their time** fiercely
- **Said no** to most things
- **Picked battles** carefully
- **Documented decisions** not just code
- **Left breadcrumbs** for future maintainers
- **Treated production like a sacred space**
- **Assumed everything would fail** and planned accordingly
- **Measured everything** they cared about
- **Refined estimates** based on past accuracy
- **Built mental models** of complex systems
- **Drew diagrams** to explain and understand
- **Paired programmed** to share knowledge
- **Code reviewed** to learn, not just approve
- **Kept ego out** of technical discussions
- **Changed their mind** with new evidence
- **Celebrated others' successes** publicly
- **Admitted ignorance** confidently
- **Asked for help** early, not as last resort

---

## What Made Them Assets (Not Just Employees)

- They **reduced risk** for the company, not just shipped features
- They **unblocked others** faster than they could code alone
- They **made decisions** when others hesitated
- They **took ownership** beyond their job description
- They **built trust** through consistent behavior
- They **stayed during hard times** and solved the hard problems
- They **multiplied the team's output** not just their own
- They **represented the company well** externally
- They were **replaceable on paper, irreplaceable in practice**

---

## The Common Thread

Not all followed every practice, but the best followed most of them, most of the time.

> **Relentless consistency over brilliance.**
